<%

## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved

unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/../impl/bin";
require OutputAssignmentGenerator;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();

# get Perl objects for input and output ports
my $inputPort = $model->getInputPortAt(0);
my $outputPort = $model->getOutputPortAt(0);

# get C++ expressions for getting the values of this operator's parameter				 
my $filter = $model->getParameterByName("filter") ? $model->getParameterByName("filter")->getValueAt(0)->getCppExpression() : undef;

# work around 'helper' initialization problem in operator class constructor			 
$model->getParameterByName("filter")->getValueAt(0)->{xml_}->{hasStreamAttributes}->[0]="true" if $filter && (index($filter, "::common_result_functions::") != -1);
$model->getParameterByName("filter")->getValueAt(0)->{xml_}->{hasStreamAttributes}->[0]="true" if $filter && (index($filter, "::TupleCounterA_result_functions::") != -1);

%>


<%SPL::CodeGen::implementationPrologue($model);%>

// calls to output assignment functions within expressions are generated with
// an explicit namespace matching the operator tempate name, so it must be
// equated to the operator's namespace

#define common_result_functions MY_OPERATOR
#define TupleCounterA_result_functions MY_OPERATOR


// Constructor
MY_OPERATOR::MY_OPERATOR()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> constructor ...", "TupleCounterA");

  tupleCounter = 0;

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> constructor ...", "TupleCounterA");
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> destructor ...", "TupleCounterA");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> destructor ...", "TupleCounterA");
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> allPortsReady() ...", "TupleCounterA");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> allPortsReady() ...", "TupleCounterA");
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> prepareToShutdown() ...", "TupleCounterA");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> prepareToShutdown() ...", "TupleCounterA");
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> prepareToShutdown() ...", "TupleCounterA");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> prepareToShutdown() ...", "TupleCounterA");
}

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process() ...", "TupleCounterA");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "TupleCounterA");
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process() ...", "TupleCounterA");

  // count this tuple
  tupleCounter++;

  // point at the input tuple
  const IPort0Type& iport$0 = tuple;

  // submit output tuples to output ports, as selected by filter, if specified
  <% if ($filter) { print "if ($filter)"; } %>
  {
    outTuple.clear();
    outTuple.assignFrom(iport$0, false);
    <% ####### OutputAssignmentGenerator::generate("outTuple", $outputPort); %> ;
    <%=SPL::CodeGen::getOutputTupleCppAssignments("outTuple", $outputPort)%> ;
    SPLLOG(L_TRACE, "submitting outTuple=" << outTuple, "TupleCounterA");
    submit(outTuple, 0);
  }

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "TupleCounterA");
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process() ...", "TupleCounterA");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "TupleCounterA");
}


<%SPL::CodeGen::implementationEpilogue($model);%>

