<%
## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved
%>


<%

### for valid values of 'networkInterface' parameter, type '/sbin/ifconfig' on deployment machine
### for valid values of 'filterExpression' parameter, see man page for 'tcpdump' at http://linux.die.net/man/8/tcpdump

use Switch;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's 
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();

# get C++ expressions for getting the values of this operator's required parameters
my $networkInterface = $model->getParameterByName("networkInterface")->getValueAt(0)->getCppExpression();
  
# get C++ expressions for getting the values of this operator's optional parameters  
my $filterExpression = $model->getParameterByName("filterExpression") ? $model->getParameterByName("filterExpression")->getValueAt(0)->getCppExpression() : undef;
my $maximumLength = $model->getParameterByName("maximumLength") ? $model->getParameterByName("maximumLength")->getValueAt(0)->getCppExpression() : "65535";
my $initDelay = $model->getParameterByName("initDelay") ? $model->getParameterByName("initDelay")->getValueAt(0)->getCppExpression() : 0.0;
my $machineID = $model->getParameterByName("machineID") ? $model->getParameterByName("machineID")->getValueAt(0)->getCppExpression() : 0;
my $bufferSize = $model->getParameterByName("bufferSize") ? $model->getParameterByName("bufferSize")->getValueAt(0)->getCppExpression() : 0;
my $promiscuous = $model->getParameterByName("promiscuous") ? $model->getParameterByName("promiscuous")->getValueAt(0)->getCppExpression() : 0;
my $processorAffinity = $model->getParameterByName("processorAffinity") ? $model->getParameterByName("processorAffinity")->getValueAt(0)->getCppExpression() : -1;
my $timeout = $model->getParameterByName("timeout") ? $model->getParameterByName("timeout")->getValueAt(0)->getCppExpression() : 0.0;
my $timestampType = $model->getParameterByName("timestampType") ? $model->getParameterByName("timestampType")->getValueAt(0)->getCppExpression() : "";
my $statisticsInterval = $model->getParameterByName("statisticsInterval") ? $model->getParameterByName("statisticsInterval")->getValueAt(0)->getCppExpression() : "1.0";

# safety check for semi-required parameters
SPL::CodeGen::exit("Sorry, 'statisticsInterval' is valid only when a second output port is defined") if $model->getParameterByName("statisticsInterval") && $model->getNumberOfOutputPorts()<2; 

# find out whether any attribute uses the sessionKey() output assignment function
my $needSessionKey = 0;
for (my $i = 0; $i < $model->getOutputPortAt(0)->getNumberOfAttributes(); ++$i) {
      	my $attribute = $model->getOutputPortAt(0)->getAttributeAt($i);
	    	next unless $attribute->hasAssignment();
   			my $function = $attribute->getAssignmentOutputFunctionName();
				$needSessionKey = 1 if $function eq "sessionKey";
}				

%>


<%SPL::CodeGen::implementationPrologue($model);%>
#include <SPL/Runtime/Common/Metric.h>
#include <SPL/Runtime/Operator/OperatorMetrics.h>


#if 0
struct groupByThree : std::numpunct<char> {
    std::string do_grouping() const { return "\3"; }  // separate digits into groups of three
    char do_thousands_sep()   const { return ','; }   // separate groups of digits with commas
};
#endif


// Constructor
MY_OPERATOR::MY_OPERATOR()
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> constructor ...", "PacketLiveSource");

	// get the operator's parameters into local constants
	networkInterface = <%=$networkInterface%>.c_str();
	const int maximumLength = <%=$maximumLength%>;
	const int bufferSize = <%=$bufferSize%>; 
	const bool promiscuous = <%=$promiscuous%>;
	const double timeout = <%=$timeout%>;
	const char* timestampType = "<%=$timestampType%>";
	machineID = <%=$machineID%>;
	statisticsInterval = <%=$statisticsInterval%>;
	char pcapError[PCAP_ERRBUF_SIZE] = "\0";
	int rc;
	
	// count the octets and packets emitted from output port 0 in these variables	
  packetCounter = 0;
  octetCounter = 0;

#if defined(lib_pcap_pcap_h)

	// log the 'libpcap' version that will be used
	SPLLOG(L_INFO, "using " << pcap_lib_version(), "PacketLiveSource");

	// open the network interface with 'libpcap' version 1.0 or later (for RHEL 6)
	SPLLOG(L_INFO, "opening network interface '" << networkInterface << "'", "PacketLiveSource");

	// create 'libpcap' descriptor for network interface
	pcapDescriptor = pcap_create(networkInterface, pcapError);
	if (!pcapDescriptor) THROW (SPLRuntimeOperator, "error creating network interface '" << networkInterface << "', " << pcapError);

#if defined(PCAP_TSTAMP_HOST) 
	// log timestamp types supported by interface
	{
	  int * timestampTypes;
	  rc = pcap_list_tstamp_types(pcapDescriptor, &timestampTypes);
	  if (rc == PCAP_ERROR) THROW (SPLRuntimeOperator, "error getting timestamp types, " << pcap_geterr(pcapDescriptor));
	  	SPLLOG(L_INFO, rc << " values available for timestampType parameter", "PacketLiveSource"); 
		for (int i = 0; i < rc; i++) {
	  	SPLLOG(L_INFO, "timestampType value '" << pcap_tstamp_type_val_to_name(timestampTypes[i]) << "' available", "PacketLiveSource"); }
	  pcap_free_tstamp_types(timestampTypes);
	}
#endif

	// put network interface into promiscuous mode, if specified
	if (promiscuous) { 
		 SPLLOG(L_INFO, "putting network interface '" << networkInterface << "' into promiscuous mode", "PacketLiveSource");
		 rc = pcap_set_promisc(pcapDescriptor, 1);
  	 if (rc) THROW (SPLRuntimeOperator, "error setting promiscuous mode, " << pcap_geterr(pcapDescriptor)); }

	// set maximum packet capture length
	SPLLOG(L_INFO, "setting maximum packet capture length to " << maximumLength << " bytes", "PacketLiveSource");
	rc = pcap_set_snaplen(pcapDescriptor, maximumLength);
	if (rc) THROW (SPLRuntimeOperator, "error setting maxmum capture length to " << maximumLength << " bytes, " << pcap_geterr(pcapDescriptor));

	// set receive timeout, if specified
  if (timeout) {
	  const int milliseconds = (int)(timeout*1000.0);
		SPLLOG(L_INFO, "setting receive timeout to " << timeout << " seconds", "PacketLiveSource");
		rc = pcap_set_timeout(pcapDescriptor, milliseconds);
		if (rc) THROW (SPLRuntimeOperator, "error setting receive timeout to " << timeout << " seconds, " << pcap_geterr(pcapDescriptor)); }
 
	// set receive buffer size, if specified
	if (bufferSize) {
		 SPLLOG(L_INFO, "setting receive buffer size to " << bufferSize << " bytes", "PacketLiveSource");
		 rc = pcap_set_buffer_size(pcapDescriptor, bufferSize); 
		 if (rc) THROW (SPLRuntimeOperator, "error setting receive buffer size to " << bufferSize << " bytes, " << pcap_geterr(pcapDescriptor)); }

	// set timestamp type, if specified
  if (strlen(timestampType)) { 
#if defined(PCAP_TSTAMP_HOST)
		 SPLLOG(L_INFO, "setting timestamp type to '" << timestampType << "'", "PacketLiveSource");
		 const int tt = pcap_tstamp_type_name_to_val(timestampType);
		 if (tt==PCAP_ERROR) THROW (SPLRuntimeOperator, "error converting '" << timestampType << "' to timestamp type, " << pcap_geterr(pcapDescriptor));
		 rc = pcap_set_tstamp_type(pcapDescriptor, tt); 
		 if (rc) THROW (SPLRuntimeOperator, "error setting timestamp type to '" << timestampType << "', " << pcap_geterr(pcapDescriptor));
#else
		 SPLLOG(L_INFO, "ignoring timestampType parameter", "PacketLiveSource");
#endif
	} 
	
	// activate 'libpcap'
	rc = pcap_activate(pcapDescriptor);
	if (rc) THROW (SPLRuntimeOperator, "error activating network interface '" << networkInterface << "', " << pcap_geterr(pcapDescriptor));

#elif defined(lib_pcap_h)

	// open the network interface with 'libpcap' version 0.9 or earlier (for RHEL 5)
	SPLLOG(L_INFO, "opening network interface '" << networkInterface << "' with old 'libpcap' API", "PacketLiveSource");

	pcapDescriptor = pcap_open_live(networkInterface, maximumLength, promiscuous, 0, pcapError);
	if (!pcapDescriptor) THROW (SPLRuntimeOperator, "error opening network interface '" << networkInterface << "', " << pcapError);

#else
	// error: 'libpcap' version is not known
#endif


	// get the IP subnet and mask of the network interface
	bpf_u_int32 ipSubnet = 0;
	bpf_u_int32 ipMask = 0;
	char ipSubnetString[INET_ADDRSTRLEN];
	char ipMaskString[INET_ADDRSTRLEN];
	rc = pcap_lookupnet(networkInterface, &ipSubnet, &ipMask, pcapError);
	if (rc) SPLLOG(L_INFO, "could not get subnet and mask for network interface '" << networkInterface << "', " << pcapError, "PacketLiveSource");
	else SPLLOG(L_INFO, "capturing packets on subnet=" << inet_ntop(AF_INET, &ipSubnet, ipSubnetString, sizeof(ipSubnetString)) << 
	                                  ", mask=" << inet_ntop(AF_INET, &ipMask, ipMaskString, sizeof(ipMaskString)), "PacketLiveSource");
	
	<% if ($filterExpression) { %>
	// compile and activate a filter expression
	const char* filterExpression = <%=$filterExpression%>.c_str();
	SPLLOG(L_INFO, "capturing packets through filter '" << filterExpression << "'", "PacketLiveSource");
	struct bpf_program filterProgram;
	rc = pcap_compile(pcapDescriptor, &filterProgram, (char*)filterExpression, 0, ipMask);
	if (rc) THROW (SPLRuntimeOperator, "error compiling PCAP filter '" << filterExpression << "', rc=" << rc << ", " << pcap_geterr(pcapDescriptor));
	rc = pcap_setfilter(pcapDescriptor, &filterProgram);
	if (rc) THROW (SPLRuntimeOperator, "error activating PCAP filter '" << filterExpression << "', rc=" << rc << ", " << pcap_geterr(pcapDescriptor));
	<% } %>	
	
 	SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> constructor ...", "PacketLiveSource");
}



// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> destructor ...", "PacketLiveSource");

	if (pcapDescriptor) { pcap_close(pcapDescriptor); }

	SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> destructor ...", "PacketLiveSource");
}



// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> allPortsReady() ...", "PacketLiveSource");

	const int threadCount = <%=$model->getNumberOfOutputPorts()%> + 1;
	SPLLOG(L_INFO, "starting " << threadCount << " threads", "PacketLiveSource");
  
	createThreads(threadCount);
  
	SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> allPortsReady() ...", "PacketLiveSource");
}
 
 
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> prepareToShutdown() ...", "PacketLiveSource");

	// tell libpcap to stop reading packets
  pcap_breakloop(pcapDescriptor);

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> prepareToShutdown() ...", "PacketLiveSource");

}



void pcapCallback( u_char* correlator, const struct pcap_pkthdr* pcapHeader, const u_char* packetPointer ) {
	MY_OPERATOR* self = (MY_OPERATOR*)correlator;
	const uint32_t caplen = pcapHeader->caplen;
	
  // ignore the packet if it has been truncated somewhere within the ethernet header
	if (caplen < sizeof(struct ethhdr)) { SPLLOG(L_DEBUG, "ignoring packet, header truncated", "PacketLiveSource");  return; }
	 
<% if ($needSessionKey) { %>

		// calculate the IP/UDP/TCP session key for this packet
		uint32_t sessionKey = 0;

	// overlay these network header structures on the packet 
	const struct ethhdr* etherHeader = (struct ethhdr*)packetPointer;
	struct ip* ipHeader = NULL;
	
	// if this is an IP packet, and it actually has an IPv4 header, overlay an IPv4 header structure on it
	if ( (ntohs(etherHeader->h_proto)==ETH_P_IP && caplen>=sizeof(struct ethhdr)+sizeof(struct ip)) ) {
		ipHeader = (struct ip*)(packetPointer + sizeof(struct ethhdr));
		sessionKey = ntohl(ipHeader->ip_src.s_addr) + ntohl(ipHeader->ip_dst.s_addr);
	}
	
	// if this is a UDP packet, and it actually has a UDP header, overlay a UDP header structure on it
	if ( (ipHeader && ipHeader->ip_p==IPPROTO_UDP && caplen>=sizeof(struct ethhdr)+sizeof(struct ip)+sizeof(struct udphdr)) ) { 
		struct udphdr* udpHeader = (struct udphdr*)(packetPointer + sizeof(struct ethhdr) + ipHeader->ip_hl*4);
		sessionKey += ntohs(udpHeader->source) + ntohs(udpHeader->dest);				
		//printf("UDP packet %lld %08x:%04x --> %08x:%04x, key=%08x\n", (long long)self->packetCounter, ntohl(ipHeader->ip_src.s_addr), ntohs(udpHeader->source), ntohl(ipHeader->ip_dst.s_addr), ntohs(udpHeader->dest), sessionKey);
	}
	
	// if this is a TCP packet, and it actually has a TCP header, overlay a TCP header structure on it
	if ( (ipHeader && ipHeader->ip_p==IPPROTO_TCP && caplen>=sizeof(struct ethhdr)+sizeof(struct ip)+sizeof(struct tcphdr)) ) { 
		struct tcphdr* tcpHeader = (struct tcphdr*)(packetPointer + sizeof(struct ethhdr) + ipHeader->ip_hl*4);
		sessionKey += ntohs(tcpHeader->source) + ntohs(tcpHeader->dest);				
		//printf("TCP packet %lld %08x:%04x --> %08x:%04x, key=%08x\n", (long long)self->packetCounter, ntohl(ipHeader->ip_src.s_addr), ntohs(tcpHeader->source), ntohl(ipHeader->ip_dst.s_addr), ntohs(tcpHeader->dest), sessionKey);
	}

<% } %>

	// assign values to output attributes
  	<% 
    my $outputPort0 = $model->getOutputPortAt(0);
    for (my $i = 0; $i < $outputPort0->getNumberOfAttributes(); ++$i) {
      	my $attribute = $outputPort0->getAttributeAt($i);
	    	next unless $attribute->hasAssignment();

   			my $name = $attribute->getName();
   			my $type = $attribute->getCppType();
   			my $function = $attribute->getAssignmentOutputFunctionName();

				if ($function eq "copy" && $attribute->getAssignmentValue()) {
		   		 my $expression = $attribute->getAssignmentValue()->getCppExpression();
		   		 print "packetTuple.set_$name( static_cast<$type>( $expression ) ); // assign expression\n";
		   		 next; }

      	switch($function) {
      		case /^timestampp$/ {
      			switch($type) {
      				case /float/     { print "    self->packetTuple.set_$name(static_cast<$type>( (double)(pcapHeader->ts.tv_sec) + ((double)(pcapHeader->ts.tv_usec))/1000000.0 ));\n"; }
      				case /int/       { print "    self->packetTuple.set_$name(static_cast<$type>( (int64_t)(pcapHeader->ts.tv_sec) ));\n"; }
      				case /timestamp/ { print "    self->packetTuple.set_$name( SPL::timestamp(pcapHeader->ts.tv_sec, pcapHeader->ts.tv_usec*1000, self->machineID) );\n"; }
      				else             { SPL::CodeGen::exitln("Sorry, unsupported type '$type' for output assignment function '$function' for attribute '$name'", $outputPort0->getSourceLocation() ); }
      			} }
      		#case /^packet$/                { print "    self->packetTuple.set_$name($type(packetPointer, caplen));\n"; }
      	  case /^packet$/                { print "    self->packetTuple.get_$name().useExternalData(const_cast<unsigned char *>(packetPointer), caplen);\n"; }
      		case /^length$/                { print "    self->packetTuple.set_$name(static_cast<$type>(pcapHeader->len));\n"; }
      		case /^packetNumber$/          { print "    self->packetTuple.set_$name(static_cast<$type>(self->packetCounter));\n"; }
      		case /^sessionKey$/            { print "    self->packetTuple.set_$name(static_cast<$type>(sessionKey));\n"; }
      	  case /^timestampSeconds$/      { print "    self->packetTuple.set_$name((int64_t) (pcapHeader->ts.tv_sec));\n"; }
      	  case /^TimestampSeconds$/      { print "    self->packetTuple.set_$name((int64_t) (pcapHeader->ts.tv_sec));\n"; }
      	  case /^timestampMicroseconds$/ { print "    self->packetTuple.set_$name((int32_t) (pcapHeader->ts.tv_usec));\n"; }
      	  case /^TimestampMicroseconds$/ { print "    self->packetTuple.set_$name((int32_t) (pcapHeader->ts.tv_usec));\n"; }
      		case /^none$/       {}
      		else { SPL::CodeGen::exitln("Sorry, unsupported output assignment function '$function' for attribute '$name'", $outputPort0->getSourceLocation() ); }
      	}
    }
  	%>

  	// send the packet tuple downstream
		//const double before = SPL::Functions::Time::getTimestampInSecs();
  	self->submit(self->packetTuple, 0);
		//const double after = SPL::Functions::Time::getTimestampInSecs();
		//if (after-before>0.001) SPLLOG(L_INFO, "packet " << self->packetCounter << " submit took " << (after-before)*1000.0 << " ms ", "PacketLiveSource");

		// count the packets and octets produced
		self->packetCounter += 1;
		self->octetCounter += pcapHeader->len;
}


	
void MY_OPERATOR::process(uint32_t idx)
{
    SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process(" << idx << ") for " << networkInterface, "PacketLiveSource");
    
    switch (idx) {
      case 0: process_pcap_packets(); break;
      case 1: process_pcap_metrics(); break;
      <% if ($model->getNumberOfOutputPorts()==2) { %>case 2: process_pcap_statistics(); break;<% } %>
      default: break; }
         
    SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process(" << idx << ") for " << networkInterface, "PacketLiveSource");
}



// this method executes on a separate thread, calling repeatedly into libpcap to
// receive ethernet packets captured from the network interface, which are emitted
// as tuples on output port 0
void MY_OPERATOR::process_pcap_packets()
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process_pcap_packets() for " << networkInterface, "PacketLiveSource");

	// get operator parameters into local variables	
	const int processorAffinity = <%=$processorAffinity%>;
	const double initDelay = <%=$initDelay%>;

#if 0
	// initialize Stream metrics
  	Metric * pcapLoops;		
	OperatorMetrics & opm = getContext().getMetrics();
	pcapLoops = & opm.getCustomMetricByName("nInterfaceOpens");
#endif
		
	// assign this thread to a particular processor core, if specified
  	if (processorAffinity>-1) {
	   SPLLOG(L_INFO, "assigning thread " << gettid() << " to processor core " << processorAffinity, "PacketLiveSource");
  	   cpu_set_t cpumask; // CPU affinity bit mask
  	   CPU_ZERO(&cpumask);
  	   CPU_SET(processorAffinity, &cpumask);
  	   const int rc = sched_setaffinity(gettid(), sizeof cpumask, &cpumask);
  	   if (rc<0) THROW (SPLRuntimeOperator, "could not set processor affinity to " << processorAffinity << ", " << strerror(errno)); } 

	// wait for a while before starting, if specified
	if (initDelay>0) { 
		 SPLLOG(L_INFO, "waiting " << initDelay << " seconds before starting", "PacketLiveSource");
		 getPE().blockUntilShutdownRequest(initDelay); } 

	// call into 'libpcap' and wait in there for callbacks
	while(!getPE().getShutdownRequested()) {		
		SPLLOG(L_TRACE, "pcap_loop() called", "PacketLiveSource");		
		const int rc = pcap_loop(pcapDescriptor, -1, &pcapCallback, (u_char*)this);
#if 0
		//pcapLoops->incrementValue(1L);
#endif
		SPLLOG(L_TRACE, "pcap_loop() returned " << rc, "PacketLiveSource"); }
	
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process_pcap_packets() for " << networkInterface, "PacketLiveSource");
}
	
	

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
}



// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
}



// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
}



<% if ($model->getNumberOfOutputPorts()==2) { %>

// This method executes on a separate thread, calling into libpcap periodically
// to get its statistcs counters, which are emitted as tuples on output port 1
// whenever they change
void MY_OPERATOR::process_pcap_statistics()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process_pcap_statistics() for " << networkInterface, "PacketLiveSource");

	// the previous values of libpcap's statistics in these variables
	struct pcap_stat statistics;
	pcap_stats(pcapDescriptor, &statistics);
	uint64_t previous_statistics_ps_recv = statistics.ps_recv;
	uint64_t previous_statistics_ps_drop = statistics.ps_drop;
	uint64_t previous_statistics_ps_ifdrop = statistics.ps_ifdrop;
	uint64_t previous_packetCounter = packetCounter;
	uint64_t previous_octetCounter = octetCounter;

	// get 'libpcap' statistics periodically and emit a tuple whenever they change
	double previous_statistics_time = SPL::Functions::Time::getTimestampInSecs();
	while (1) {

				// wait until its time for the next statistics tuple
				double now = SPL::Functions::Time::getTimestampInSecs();
				const double timeToWait = previous_statistics_time + statisticsInterval - now;
				if (timeToWait>0) {
					 getPE().blockUntilShutdownRequest(timeToWait);				
	  			 if (getPE().getShutdownRequested()) break;
					 now = SPL::Functions::Time::getTimestampInSecs();
				} else {
					SPLLOG(L_TRACE, "missed statistics interval by " << -timeToWait << " seconds for " << networkInterface, "PacketLiveSource");
				}

	  // get current statistics and calculate changes since last time
		pcap_stats(pcapDescriptor, &statistics);
		uint64_t packetsReceived = statistics.ps_recv - previous_statistics_ps_recv;
		uint64_t packetsDropped = statistics.ps_drop - previous_statistics_ps_drop;
		uint64_t packetsDroppedByInterface = statistics.ps_ifdrop - previous_statistics_ps_ifdrop;
	  uint64_t packetsProduced = packetCounter - previous_packetCounter;
	  uint64_t octetsProduced = octetCounter - previous_octetCounter;

		// emit a statistics tuple only if at least one counter has changed
		if ( packetsReceived || packetsDropped || packetsDroppedByInterface || packetsProduced ) {

			 // assign values to output attributes
  		 <% 
   		 my $outputPort1 = $model->getOutputPortAt(1);
    	 for (my $i = 0; $i < $outputPort1->getNumberOfAttributes(); ++$i) {
			       	my $attribute = $outputPort1->getAttributeAt($i);
	    				next unless $attribute->hasAssignment();

   						my $name = $attribute->getName();
   						my $type = $attribute->getCppType();
   						my $function = $attribute->getAssignmentOutputFunctionName();

							if ($function eq "copy" && $attribute->getAssignmentValue()) {
		   					 my $expression = $attribute->getAssignmentValue()->getCppExpression();
		   					 print "statisticsTuple.set_$name( static_cast<$type>( $expression ) ); // assign expression\n";
		   					 next; }

      				switch($function) {
      				case /^timestampp$/ {
      							switch($type) {
      											case /float/     { print "    statisticsTuple.set_$name(static_cast<$type>( (double)(now) ));\n"; }
      											case /int/       { print "    statisticsTuple.set_$name(static_cast<$type>( (int64_t)(now) ));\n"; }
      											case /timestamp/ { print "    statisticsTuple.set_$name( SPL::timestamp( now ));\n"; }
      											else             { SPL::CodeGen::exitln("Sorry, unsupported type '$type' for output assignment function '$function' for attribute '$name'", $outputPort1->getSourceLocation() ); }
      							} }
      	  		case /^packetsReceived$/           { print "    statisticsTuple.set_$name(($type)packetsReceived);\n"; }
      				case /^packetsDropped$/            { print "    statisticsTuple.set_$name(($type)packetsDropped);\n"; }
      	  		case /^packetsDroppedByInterface$/ { print "    statisticsTuple.set_$name(($type)packetsDroppedByInterface);\n"; }
      	  		case /^packetsProduced$/           { print "    statisticsTuple.set_$name(($type)packetsProduced);\n"; }
      	  		case /^octetsProduced$/            { print "    statisticsTuple.set_$name(($type)octetsProduced);\n"; }
      				case /^none$/       {}
      				else { SPL::CodeGen::exitln("Sorry, unsupported output assignment function '$function' for attribute '$name'", $outputPort1->getSourceLocation() ); }
      				}
    	}
  	  %>

			// send the statistics tuple to downstream operators 
			submit(statisticsTuple, 1); 
			}

	// save the current statistics values for next time
	previous_statistics_ps_recv = statistics.ps_recv;
	previous_statistics_ps_drop = statistics.ps_drop;
	previous_statistics_ps_ifdrop = statistics.ps_ifdrop;
  previous_packetCounter = packetCounter;
  previous_octetCounter = octetCounter;

	// save the time this statistics tuple was submitted, too												
	previous_statistics_time = now;
	}		

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process_pcap_statistics() for " << networkInterface, "PacketLiveSource");
}

<% } %>



// Periodic fetch of metrics from PCAP library. 
void MY_OPERATOR::process_pcap_metrics()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process_pcap_metrics() for " << networkInterface, "PacketLiveSource");
	Metric * totalPackets;
	Metric * totalPacketsDropped;
	Metric * totalPacketsDroppedByInterface;
	const Metric * tuples;
	
	OperatorMetrics & opm = getContext().getMetrics();
	totalPackets = & opm.getCustomMetricByName("nPacketsReceivedCurrent");
	totalPacketsDropped = & opm.getCustomMetricByName("nPacketsDroppedCurrent");
	totalPacketsDroppedByInterface = & opm.getCustomMetricByName("nPacketsDroppedByInterfaceCurrent");
	
	tuples = & opm.getOutputPortMetric(0, OperatorMetrics::nTuplesSubmitted);
		
	while(!getPE().blockUntilShutdownRequest(5.0)) {		

		struct pcap_stat stats;
		pcap_stats(pcapDescriptor, &stats);
		
		uint64_t tr = stats.ps_recv - totalPackets->getValue();
		uint64_t td = stats.ps_drop - totalPacketsDropped->getValue();
		uint64_t tdi = stats.ps_ifdrop - totalPacketsDroppedByInterface->getValue();
		
		totalPackets->setValue(stats.ps_recv);
		totalPacketsDropped->setValue(stats.ps_drop);
		totalPacketsDroppedByInterface->setValue(stats.ps_ifdrop);

    if (tr != 0) {
		    SPLLOG(L_DEBUG, networkInterface << " :: " << totalPackets->getValue() << " :: " << totalPackets->getDescription(), "PacketLiveSource");
	      SPLLOG(L_DEBUG, networkInterface << " :: " << totalPacketsDropped->getValue() << " :: " << totalPacketsDropped->getDescription(), "PacketLiveSource");
	      SPLLOG(L_DEBUG, networkInterface << " :: " << totalPacketsDroppedByInterface->getValue() << " :: " << totalPacketsDroppedByInterface->getDescription(), "PacketLiveSource");
	      SPLLOG(L_DEBUG, networkInterface << " :: " << tuples->getValue() << " :: " << tuples->getDescription(), "PacketLiveSource");
	    
		    double pcd = 100.0 * (((double) (td + tdi)) / ((double) tr));
		    uint64_t pps = tr / (uint64_t) 3;
		    SPLLOG(L_DEBUG, networkInterface << ": packets percent dropped=" << pcd, "PacketLiveSource");
		    SPLLOG(L_DEBUG, networkInterface << ": packets per second     =" << pps, "PacketLiveSource");
		}
	}

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process_pcap_metrics() for " << networkInterface, "PacketLiveSource");
}





<%SPL::CodeGen::implementationEpilogue($model);%>
