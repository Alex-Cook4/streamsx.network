<%
## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved
%>


#include <iostream>
#include <iomanip>
#include <limits>
#include <locale>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include <sched.h>
#include <pcap.h>

#include <streams_boost/filesystem.hpp>

#include <SPL/Runtime/Common/Metric.h>
#include <SPL/Runtime/Operator/OperatorMetrics.h>

#include "parse/NetworkHeaderLocator.h"


<%SPL::CodeGen::headerPrologue($model);%>

class MY_OPERATOR : public MY_BASE_OPERATOR 
{
public:

  // ----------- standard operator methods ----------

  MY_OPERATOR();
  virtual ~MY_OPERATOR(); 
  void allPortsReady(); 
  void prepareToShutdown(); 
  void process(uint32_t idx);
  void process(Tuple & tuple, uint32_t port);
  void process(Tuple const & tuple, uint32_t port);
  void process(Punctuation const & punct, uint32_t port);

  // ----------- additional operator methods ----------

  void statistics_thread(); 
  void pcap_thread();
  void processPCAPbuffer(const struct pcap_pkthdr* header, const u_char* buffer); 


private:

  // ----------- operator parameters (constant after constructor executes) ----------
 
  std::string networkInterface;
  std::string filterExpression;
  std::string timestampType;
  double initDelay;
  int32_t processorAffinity;
  int32_t maximumLength;
  int32_t bufferSize;
  bool promiscuous;
  double timeout;
  double statisticsInterval;

  // ----------- operator state variables ----------

  double now;

  struct pcap_stat pcapStatistics, previousPCAPStatistics;

  uint64_t packetCounter, previousPacketCounter;
  uint64_t octetCounter, previousOctetCounter;

  // ----------- libpcap-specific variables ----------

  pcap_t* pcapDescriptor;
  const struct pcap_pkthdr* pcapHeader;
  const u_char* pcapBuffer;

  // ----------- network header locator ----------

  NetworkHeaderLocator headers;

  // ----------- output attribute assignment functions for packet stream (port 0) ----------

  double captureTime() { return (double)(pcapHeader->ts.tv_sec) + ((double)(pcapHeader->ts.tv_usec))/1000000.0; }

  uint64_t packetNumber() { return packetCounter; }  

  uint32_t packetLength() { return headers.packetFullLength; } 

  SPL::blob packetData() {return SPL::blob((const unsigned char*)headers.packetBuffer, headers.packetCapturedLength); }  

  uint32_t sessionKey() { // this output assignment function will probably be removed ?????????????????
    uint32_t key = 0;
    if (headers.ipv4Header) key += ntohl(headers.ipv4Header->ip_src.s_addr) + ntohl(headers.ipv4Header->ip_dst.s_addr);
    if (headers.udpHeader) key += ntohs(headers.udpHeader->source) + ntohs(headers.udpHeader->dest);
    if (headers.tcpHeader) key += ntohs(headers.tcpHeader->source) + ntohs(headers.tcpHeader->dest);				
    return key; }

  // ---------- output attribute assignment functions for statistics stream (port 1) ----------

  double statisticsTime() { return now; }

  uint64_t packetsReceived() { return pcapStatistics.ps_recv - previousPCAPStatistics.ps_recv; }  

  uint64_t packetsDropped() { return pcapStatistics.ps_drop - previousPCAPStatistics.ps_drop; }  

  uint64_t packetsDroppedByInterface() { return pcapStatistics.ps_ifdrop - previousPCAPStatistics.ps_ifdrop; }  

  uint64_t packetsProduced() { return packetCounter - previousPacketCounter; }  

  uint64_t octetsProduced() { return octetCounter - previousOctetCounter; }  

  // ------------------------------------------------------------------------------------------

}; 

<%SPL::CodeGen::headerEpilogue($model);%>

