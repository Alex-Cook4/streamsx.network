<%

## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved

unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/Common";
require OutputAssignmentGenerator;
use Switch;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();

# get Perl objects for input and output ports
my $inputPort = $model->getNumberOfInputPorts()>0 ? $model->getInputPortAt(0) : undef;
my $outputPort0 = $model->getNumberOfOutputPorts()>0 ? $model->getOutputPortAt(0) : undef;
my $outputPort1 = $model->getNumberOfOutputPorts()>1 ? $model->getOutputPortAt(1) : undef;

# get C++ type of input tuple, if there is one
my $inputPortType = $inputPort ? $inputPort->getCppTupleType() : undef;

# get C++ expressions for getting the values of this operator's optional parameters
my $pcapFilename = $model->getParameterByName("pcapFilename") ? $model->getParameterByName("pcapFilename")->getValueAt(0)->getCppExpression() : undef;
my $filterExpression = $model->getParameterByName("filterExpression") ? $model->getParameterByName("filterExpression")->getValueAt(0)->getCppExpression() : "\"\"";
my $initDelay = $model->getParameterByName("initDelay") ? $model->getParameterByName("initDelay")->getValueAt(0)->getCppExpression() : 0;
my $processorAffinity = $model->getParameterByName("processorAffinity") ? $model->getParameterByName("processorAffinity")->getValueAt(0)->getCppExpression() : -1;
my $statisticsInterval = $model->getParameterByName("statisticsInterval") ? $model->getParameterByName("statisticsInterval")->getValueAt(0)->getCppExpression() : 1.0;

# basic safety checks
SPL::CodeGen::exit("Sorry, either 'pcapFilename' parameter or an input port must be specified") unless $pcapFilename || $inputPort;
SPL::CodeGen::exit("Sorry, 'pcapFilename' parameter and an input port cannot both be specified") if $pcapFilename && $inputPort;
SPL::CodeGen::exit("Sorry, 'initDelay' can only be specified when 'pcapFilename' is also specified") if $initDelay && !$pcapFilename;
SPL::CodeGen::exit("Sorry, 'processorAffinity' can only be specified when 'pcapFilename' is also specified") if $processorAffinity>=0 && !$pcapFilename;

%>



<%SPL::CodeGen::implementationPrologue($model);%>





// calls to output assignment functions within expressions are generated with
// an explicit namespace matching the operator tempate name, so it must be
// equated to the operator's namespace

#define PacketFileSource MY_OPERATOR




struct groupByThree : std::numpunct<char> {
  std::string do_grouping() const { return "\3"; }  // separate digits into groups of three
  char do_thousands_sep()   const { return ','; }   // separate groups of digits with commas
};



// Constructor
MY_OPERATOR::MY_OPERATOR()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> constructor ...", "PacketFileSource");

  // set operator parameters
  filterExpression = <%=$filterExpression%>;
  initDelay = <%=$initDelay%>;
  processorAffinity = <%=$processorAffinity%>;
  statisticsInterval = <%=$statisticsInterval%>;

  // initialize operator state variables
  startTimeInNanoseconds = SPL::Functions::Time::getCPUCounterInNanoSeconds();
  packetCounter = 0;
  octetCounter = 0;
  done = false;

  // clear the dummy ethernet header
  memset(&dummyEthernetHeader, 0, sizeof(dummyEthernetHeader));

#if defined(lib_pcap_pcap_h)
  // log the 'libpcap' version that will be used
  SPLLOG(L_INFO, "using " << pcap_lib_version(), "PacketLiveSource");
#endif

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> constructor ...", "PacketFileSource");
}



// Destructor
MY_OPERATOR::~MY_OPERATOR()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> destructor ...", "PacketFileSource");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> destructor ...", "PacketFileSource");
}



// Notify port readiness
void MY_OPERATOR::allPortsReady()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> allPortsReady() ...", "PacketFileSource");

  const int threadCount = <%=$inputPort?0:1%> + <%=$outputPort1?1:0%>;
  SPLLOG(L_INFO, "starting " << threadCount << " threads", "PacketLiveSource");
  createThreads(threadCount);

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> allPortsReady() ...", "PacketFileSource");
}



// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown()
{
  // calculate elapsed time, excluding initialization and termination, but including enqueued tuples
  const uint64_t endTimeInNanoseconds = SPL::Functions::Time::getCPUCounterInNanoSeconds();
  const double elapsedSeconds = (double)(endTimeInNanoseconds-startTimeInNanoseconds) / 1000000000.0;

  // create a formatter for large numbers to be logged below
  std::stringstream formattingStream;
  formattingStream.imbue(std::locale(formattingStream.getloc(), new groupByThree));

  // log packet and octet counters, average processing rates
  formattingStream.str("");
  formattingStream << "read " << packetCounter << " packets in " << std::fixed << std::setprecision(3) << elapsedSeconds << " seconds, average " << ((double)packetCounter / elapsedSeconds) << " packets/second";
  SPLLOG(L_INFO, formattingStream.str(), "PacketFileSource");
  formattingStream.str("");
  formattingStream << "read " << octetCounter << " octets in " << std::fixed << std::setprecision(3) << elapsedSeconds << " seconds, average " << ((double)octetCounter / elapsedSeconds) << " octets/second";
  SPLLOG(L_INFO, formattingStream.str(), "PacketFileSource");
  formattingStream.str("");
  formattingStream << "read " << octetCounter*8 << " bits in " << std::fixed << std::setprecision(3) << elapsedSeconds << " seconds, average " << ((double)octetCounter*8 / elapsedSeconds) << " bits/second";
  SPLLOG(L_INFO, formattingStream.str(), "PacketFileSource");
}



// start processing threads
void MY_OPERATOR::process(uint32_t idx)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process(" << idx << ") ...", "PacketFileSource");

<% if (!$inputPort && $outputPort1) { %>

	switch (idx) {
	    case 0: file_thread(); break;
	    case 1: statistics_thread(); break;
	    default: break; }
	
<% } elsif ($inputPort && $outputPort1) { %>
	
	statistics_thread();
	
<% } elsif (!$inputPort && !$outputPort1) { %>
	
	file_thread();
	
<% } %>

	SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "PacketFileSource");
}



// Tuple processing for mutating ports
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
}



// processing for non-source operator (that is, where an input port is configured)
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
<% if ($inputPort) { %>

	if (getPE().getShutdownRequested()) return;

	// point at the input tuple
	inTuple = (Tuple*)&tuple;
	<% my $tupleType = $inputPort->getCppTupleType(); %>
	const <%=$tupleType%>& thisTuple = static_cast<const <%=$tupleType%>&>(tuple);

	// get the value of the first attribute
	<% my $attributeName = $inputPort->getAttributeAt(0)->getName(); %>
	const std::string pcapFilename = static_cast<const std::string>(thisTuple.get_<%=$attributeName%>());

	// process the PCAP input file specified by the first attribute in the tuple
	processPCAPfile(pcapFilename);

<% } %>
}



// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
SPLLOG(L_INFO, "entering <%=$myOperatorKind%> process(" << punct << ") ...", "PacketFileSource");  


// ... set the 'done' flag ????


SPLLOG(L_INFO, "leaving <%=$myOperatorKind%> process(" << punct << ") ...", "PacketFileSource");  
}



// Process one PCAP file, specified either with a parameter or an input tuple
void MY_OPERATOR::processPCAPfile(const std::string pcapFilename)
{
  char pcapError[PCAP_ERRBUF_SIZE] = "\0";

  SPLLOG(L_INFO, "opening PCAP file '" << pcapFilename << "'", "PacketFileSource");
  pcap_t* pcapDescriptor = pcap_open_offline(pcapFilename.c_str(), pcapError);
  if (!pcapDescriptor) THROW (SPLRuntimeOperator, "error opening PCAP file '" << pcapFilename << "', " << pcapError);

  // remember whether or not packets in this PCAP file have ethernet headers
  const int linktype = pcap_datalink(pcapDescriptor);
  SPLLOG(L_INFO, "PCAP linktype of file is " << linktype, "PacketFileSource");
  bool isRawIP = false;
  switch(linktype) {
    case DLT_EN10MB: isRawIP = false; break;
    case DLT_RAW: isRawIP = true; break;
    default: THROW (SPLRuntimeOperator, "unsupported PCAP linktype " << linktype << " in file '" << pcapFilename << "', " << pcapError);
  }

  // compile and activate a filter expression, if there is one
  if (!filterExpression.empty()) {
	int rc;
	SPLLOG(L_INFO, "filtering packets with '" << filterExpression << "'", "PacketFileSource");
	struct bpf_program filterProgram;
	rc = pcap_compile(pcapDescriptor, &filterProgram, filterExpression.c_str(), 0, 0);
	if (rc) THROW (SPLRuntimeOperator, "error compiling PCAP filter '" << filterExpression << "', rc=" << rc << ", " << pcap_geterr(pcapDescriptor));
	rc = pcap_setfilter(pcapDescriptor, &filterProgram);
	if (rc) THROW (SPLRuntimeOperator, "error activating PCAP filter '" << filterExpression << "', rc=" << rc << ", " << pcap_geterr(pcapDescriptor));
  }

  // the output tuple
  OPort0Type outTuple;

  // process each packet in the PCAP file
  while(!getPE().getShutdownRequested()) {

	// get the next packet, if there is one
	int rc = pcap_next_ex(pcapDescriptor, &pcapHeader, (const u_char**)(&pcapBuffer));
	if (rc==-2) break; // end of file
	if (rc==-1) THROW (SPLRuntimeOperator, "error reading PCAP file, " << strerror(errno)); // something went wrong
	//if (rc==0) ... // got another packet to process

	// find the network headers in the packet
	parseNetworkHeaders((char*)pcapBuffer, pcapHeader->caplen, pcapHeader->len, isRawIP);
	if (!ipv4Header) { SPLLOG(L_INFO, "ignoring packet, no IPv4 header found", "PacketFileSource");  continue; }

	// clear the output tuple
	outTuple.clear();

	// copy compatible attributes into output tuple from input tuple, if there is one
	<% if ($inputPort) { %> outTuple.assignFrom(static_cast<const <%=$inputPortType%>&>(*inTuple), false); <% } %>

	// assign computed values to output attributes
	<% OutputAssignmentGenerator::generate("outTuple", $model->getOutputPortAt(0)); %>

		 // send the packet tuple downstream
		 SPLLOG(L_TRACE, "submitting outTuple=" << outTuple, "PacketFileSource");
		 submit(outTuple, 0);

		 // count the packets and octets processed
		 packetCounter++;
		 octetCounter += pcapHeader->len;
  }

  // close the PCAP file before returning
  pcap_close(pcapDescriptor);

  SPLLOG(L_INFO, "closing PCAP file '" << pcapFilename << "'", "PacketFileSource");
}





<% if ($pcapFilename) { %>

// When there is no input port, this thread processes the PCAP file specified with the 'pcapFilename' parameter

void MY_OPERATOR::file_thread()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> file_thread()", "PacketFileSource");

  // assign this thread to a particular processor core, if necessary
  if (processorAffinity>=0) { 
	SPLLOG(L_INFO, "assigning thread " << gettid() << " to processor core " << processorAffinity, "PacketFileSource");
	cpu_set_t cpumask; // CPU affinity bit mask
	CPU_ZERO(&cpumask);
	CPU_SET(processorAffinity, &cpumask);
	const int rc = sched_setaffinity(gettid(), sizeof cpumask, &cpumask);
	if (rc<0) THROW (SPLRuntimeOperator, "could not set processor affinity to " << processorAffinity << ", " << strerror(errno));
  }

  // wait for a while before starting, if necessary
  if (initDelay>0) {
	SPLLOG(L_INFO, "waiting " << initDelay << " seconds before starting", "PacketFileSource");
	getPE().blockUntilShutdownRequest(initDelay);
	if (getPE().getShutdownRequested()) return;
  }

  // process the PCAP input file specified by the 'pcapFilename' parameter
  const std::string pcapFilename = static_cast<const std::string>(<%=$pcapFilename%>);
  processPCAPfile(pcapFilename);
  done = true;

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> file_thread()", "PacketFileSource");
}

<% } %>




<% if ($outputPort1) { %>

// When a second output port is configured, this thread periodically calls into libpcap
// to get its statistcs counters, which are emitted as tuples on that output port

void MY_OPERATOR::statistics_thread()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> statistics_thread()", "PacketFileSource");

  // keep the previous interval's statistics in these variables
  previousPacketCounter = packetCounter;
  previousOctetCounter = octetCounter;

  // the output tuple
  OPort1Type outTuple;

  // get statistics periodically and emit a tuple whenever they change
  double previousStatisticsTime = SPL::Functions::Time::getTimestampInSecs();
  while (!done && !getPE().getShutdownRequested()) {

	// wait until the next interval, or the 'file' thread finishes, or the PE is shutting down
	now = SPL::Functions::Time::getTimestampInSecs();
	const double secondsToWait = previousStatisticsTime + statisticsInterval - now;
	if (secondsToWait>0) {
	  SPLLOG(L_DEBUG, "next statistics interval in " << secondsToWait << " seconds", "PacketFileSource");
	  getPE().blockUntilShutdownRequest(secondsToWait);
	  if (done || getPE().getShutdownRequested()) return;
	  now = SPL::Functions::Time::getTimestampInSecs();
	} else {
	  SPLLOG(L_DEBUG, "missed statistics interval by " << -secondsToWait << " seconds", "PacketFileSource");
	}

	// emit a statistics tuple if they have changed since the last interval
	if ( packetCounter != previousPacketCounter ) {
	  outTuple.clear();
	  <% OutputAssignmentGenerator::generate("outTuple", $model->getOutputPortAt(1)); %>
	  SPLLOG(L_TRACE, "submitting outTuple=" << outTuple, "PacketFileSource");
	  submit(outTuple, 1);
	}
	
	// save the current statistics values for next time
	previousPacketCounter = packetCounter;
	previousOctetCounter = octetCounter;
	previousStatisticsTime = now;
  }

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> statistics_thread()", "PacketFileSource");
}

<% } %>





<%SPL::CodeGen::implementationEpilogue($model);%>
