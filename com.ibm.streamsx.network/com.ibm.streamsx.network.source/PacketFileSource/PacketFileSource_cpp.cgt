<%
## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved
%>

<%

unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/Common";
require OutputAssignmentGenerator;
use Switch;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's 
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();
  
# get C++ expressions for getting the values of this operator's optional parameters  
my $pcapFilename = $model->getParameterByName("pcapFilename") ? $model->getParameterByName("pcapFilename")->getValueAt(0)->getCppExpression() : undef;
my $filterExpression = $model->getParameterByName("filterExpression") ? $model->getParameterByName("filterExpression")->getValueAt(0)->getCppExpression() : undef;
my $initDelay = $model->getParameterByName("initDelay") ? $model->getParameterByName("initDelay")->getValueAt(0)->getCppExpression() : undef;
my $processorAffinity = $model->getParameterByName("processorAffinity") ? $model->getParameterByName("processorAffinity")->getValueAt(0)->getCppExpression() : undef;
my $statisticsInterval = $model->getParameterByName("statisticsInterval") ? $model->getParameterByName("statisticsInterval")->getValueAt(0)->getCppExpression() : "1.0";

# get Perl object for optional input port   
my $inputPort = $model->getNumberOfInputPorts()>0 ? $model->getInputPortAt(0) : undef;

# basic safety checks
SPL::CodeGen::exit("Sorry, either 'pcapFilename' parameter or an input port must be specified") unless $pcapFilename || $inputPort;
SPL::CodeGen::exit("Sorry, 'pcapFilename' parameter and an input port cannot both be specified") if $pcapFilename && $inputPort;
SPL::CodeGen::exit("Sorry, 'initDelay' can only be specified when 'pcapFilename' is also specified") if $initDelay && !$pcapFilename;
SPL::CodeGen::exit("Sorry, 'processorAffinity' can only be specified when 'pcapFilename' is also specified") if $processorAffinity && !$pcapFilename;
SPL::CodeGen::exit("Sorry, 'statisticsInterval' is valid only when a second output port is defined") if $model->getParameterByName("statisticsInterval") && $model->getNumberOfOutputPorts()<2; 

# find out whether any attribute uses the sessionKey() output assignment function
my $needSessionKey = 0;
for (my $i = 0; $i < $model->getOutputPortAt(0)->getNumberOfAttributes(); ++$i) {
      	my $attribute = $model->getOutputPortAt(0)->getAttributeAt($i);
	    	next unless $attribute->hasAssignment();
   			my $function = $attribute->getAssignmentOutputFunctionName();
				$needSessionKey = 1 if $function eq "sessionKey";
}				

%>



<%SPL::CodeGen::implementationPrologue($model);%>





// calls to output assignment functions within expressions are generated with 
// an explicit namespace matching the operator tempate name, so it must be 
// equated to the operator's namespace

#define PacketFileSource MY_OPERATOR 




struct groupByThree : std::numpunct<char> {
    std::string do_grouping() const { return "\3"; }  // separate digits into groups of three
    char do_thousands_sep()   const { return ','; }   // separate groups of digits with commas
};



// Constructor
MY_OPERATOR::MY_OPERATOR()
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> constructor ...", "PacketFileSource");
	
	// set machine identifer, in case 'timestampp() output function assigns to type 'SPL::timestamp'
	statisticsInterval = <%=$statisticsInterval%>;

	// initialize packet and octet counters
  pcapDescriptor = NULL;
	packetCounter = 0;
	octetCounter = 0;
	startTime = SPL::Functions::Time::getCPUCounterInNanoSeconds();

	// initialize the dummy ethernet header, in case the packets in the file do not have them
	memset(&dummyEthernetHeader, 0, sizeof(dummyEthernetHeader));

#if defined(lib_pcap_pcap_h)
	// log the 'libpcap' version that will be used
	SPLLOG(L_INFO, "using " << pcap_lib_version(), "PacketLiveSource");
#endif

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> constructor ...", "PacketFileSource");
}



// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> destructor ...", "PacketFileSource");
	SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> destructor ...", "PacketFileSource");
}



// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> allPortsReady() ...", "PacketFileSource");

	const int threadCount = <%=$pcapFilename?1:0%> + <%=$model->getNumberOfOutputPorts()==2?1:0%>;
	SPLLOG(L_INFO, "starting " << threadCount << " threads", "PacketLiveSource");
	createThreads(threadCount);
	
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> allPortsReady() ...", "PacketFileSource");
}


 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
  // calculate elapsed time, excluding initialization and termination, but including enqueued tuples
	const uint64_t endTime = SPL::Functions::Time::getCPUCounterInNanoSeconds();
  const double elapsedSeconds = (double)(endTime-startTime) / 1000000000.0;

	// create a formatter for large numbers to be logged below
  std::stringstream formattingStream;
  formattingStream.imbue(std::locale(formattingStream.getloc(), new groupByThree));

	// log packet and octet counters, average processing rates
	formattingStream.str("");
  formattingStream << "read " << packetCounter << " packets in " << std::fixed << std::setprecision(3) << elapsedSeconds << " seconds, average " << ((double)packetCounter / elapsedSeconds) << " packets/second";
  SPLLOG(L_INFO, formattingStream.str(), "PacketFileSource");
	formattingStream.str("");
  formattingStream << "read " << octetCounter << " octets in " << std::fixed << std::setprecision(3) << elapsedSeconds << " seconds, average " << ((double)octetCounter / elapsedSeconds) << " octets/second";
  SPLLOG(L_INFO, formattingStream.str(), "PacketFileSource");
	formattingStream.str("");
  formattingStream << "read " << octetCounter*8 << " bits in " << std::fixed << std::setprecision(3) << elapsedSeconds << " seconds, average " << ((double)octetCounter*8 / elapsedSeconds) << " bits/second";
  SPLLOG(L_INFO, formattingStream.str(), "PacketFileSource");
}



// processing thread for source operator (that is, where no input port is configured)   
void MY_OPERATOR::process(uint32_t idx)
{
	SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process(" << idx << ") ...", "PacketFileSource");
	
<% if ($pcapFilename && $model->getNumberOfOutputPorts()==2) { %>

	switch (idx) {
				 case 0: file_thread(); break;
				 case 1: statistics_thread(); break;
  			 default: break; }

<% } elsif ($pcapFilename && $model->getNumberOfOutputPorts()==1) { %>  

	file_thread(); 

<% } elsif (!$pcapFilename && $model->getNumberOfOutputPorts()==2) { %>  

	statistics_thread(); 

<% } %>
	
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "PacketFileSource");
}



// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
}



// processing for non-source operator (that is, where an input port is configured)
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
	<% if ($inputPort) { %>

	if (getPE().getShutdownRequested()) return;

  // point at the input tuple
	inTuple = tuple;
  <% my $tupleType = $inputPort->getCppTupleType(); %>
  const <%=$tupleType%>& thisTuple = static_cast<const <%=$tupleType%>&>(tuple);
    	
  // get the value of the first attribute
  <% my $attributeName = $inputPort->getAttributeAt(0)->getName(); %>
  const std::string pcapFilename = static_cast<const std::string>(thisTuple.get_<%=$attributeName%>());
    
	// process the PCAP input file specified by the first attribute in the tuple
	processPCAPfile(pcapFilename);

	<% } %>
}



// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
}



// Process one PCAP file, specified either with a parameter or an input tuple   
void MY_OPERATOR::processPCAPfile(const std::string pcapFilename)
{
	char pcapError[PCAP_ERRBUF_SIZE] = "\0";

	SPLLOG(L_INFO, "opening PCAP file '" << pcapFilename << "'", "PacketFileSource");
	pcapDescriptor = pcap_open_offline(pcapFilename.c_str(), pcapError);
	if (!pcapDescriptor) THROW (SPLRuntimeOperator, "error opening PCAP file '" << pcapFilename << "', " << pcapError);
	
	// remember whether or not packets in this PCAP file have ethernet headers
	const int linktype = pcap_datalink(pcapDescriptor);
	SPLLOG(L_INFO, "PCAP linktype of file is " << linktype, "PacketFileSource");
	switch(linktype) {
		case DLT_EN10MB: isRawIP = false; break;
		case DLT_RAW: isRawIP = true; break;
		default: THROW (SPLRuntimeOperator, "unsupported PCAP linktype " << linktype << " in file '" << pcapFilename << "', " << pcapError);
	}	

	<% if ($filterExpression) { %> {
		// compile and activate a filter expression
		int rc;
		const char* filterExpression = <%=$filterExpression%>.c_str();
		SPLLOG(L_INFO, "reading packets through filter '" << filterExpression << "'", "PacketFileSource");
		struct bpf_program filterProgram;
		rc = pcap_compile(pcapDescriptor, &filterProgram, (char*)filterExpression, 0, 0);
		if (rc) THROW (SPLRuntimeOperator, "error compiling PCAP filter '" << filterExpression << "', rc=" << rc << ", " << pcap_geterr(pcapDescriptor));
		rc = pcap_setfilter(pcapDescriptor, &filterProgram);
		if (rc) THROW (SPLRuntimeOperator, "error activating PCAP filter '" << filterExpression << "', rc=" << rc << ", " << pcap_geterr(pcapDescriptor));
	} <% } %>	

	// process each packet in the PCAP file
	while(!getPE().getShutdownRequested()) {
	
		  // get the next packet, if there is one 
    	struct pcap_pkthdr* pcapHeader;
    	const u_char* packetPointer;
    	int rc = pcap_next_ex(pcapDescriptor, &pcapHeader, &packetPointer);
    	if (rc==-2) break; // end of file
    	if (rc==-1) THROW (SPLRuntimeOperator, "error reading PCAP file, " << strerror(errno));
    	//if (rc==0) ... // got another record
    	
    	// ignore the packet if it has been truncated somewhere within the ethernet header (assuming it has one)
			const uint32_t caplen = pcapHeader->caplen;
			if (!isRawIP && caplen < sizeof(struct ethhdr)) { SPLLOG(L_DEBUG, "ignoring packet, ethernet header truncated", "PacketFileSource");  continue; }

	// point at the ethernet header
	etherHeader = NULL;
	if (!isRawIP) etherHeader = (struct ethhdr*)packetPointer;

	// if this is an IP packet, and it actually has an IPv4 header, overlay an IPv4 header structure on it
	ipHeader = NULL;
	if ( etherHeader && ntohs(etherHeader->h_proto)==ETH_P_IP && caplen>=sizeof(struct ethhdr)+sizeof(struct ip) ) {
		ipHeader = (struct ip*)(packetPointer + sizeof(struct ethhdr)); }
	else if ( isRawIP && caplen>=sizeof(struct ip) ) {
		ipHeader = (struct ip*)packetPointer; }

	// ??? if (ipHeader) { sessionKeyValue = ntohl(ipHeader->ip_src.s_addr) + ntohl(ipHeader->ip_dst.s_addr); }

	// if this is a UDP packet, and it actually has a UDP header, overlay a UDP header structure on it
	udpHeader = NULL;
	if ( (ipHeader && ipHeader->ip_p==IPPROTO_UDP && caplen>=sizeof(struct ethhdr)+sizeof(struct ip)+sizeof(struct udphdr)) ) { 
		udpHeader = (struct udphdr*)((uint8_t*)ipHeader + ipHeader->ip_hl*4);
		// ??? sessionKeyValue += ntohs(udpHeader->source) + ntohs(udpHeader->dest);				
		// ??? printf("UDP packet %lld %08x:%04x --> %08x:%04x\n", (long long)packetCounter, ntohl(ipHeader->ip_src.s_addr), ntohs(udpHeader->source), ntohl(ipHeader->ip_dst.s_addr), ntohs(udpHeader->dest));
	}
	
	// if this is a TCP packet, and it actually has a TCP header, overlay a TCP header structure on it
	tcpHeader = NULL;
	if ( (ipHeader && ipHeader->ip_p==IPPROTO_TCP && caplen>=sizeof(struct ethhdr)+sizeof(struct ip)+sizeof(struct tcphdr)) ) { 
		tcpHeader = (struct tcphdr*)((uint8_t*)ipHeader + ipHeader->ip_hl*4);
		// ??? sessionKeyValue += ntohs(tcpHeader->source) + ntohs(tcpHeader->dest);				
		// ??? printf("TCP packet %lld %08x:%04x --> %08x:%04x\n", (long long)packetCounter, ntohl(ipHeader->ip_src.s_addr), ntohs(tcpHeader->source), ntohl(ipHeader->ip_dst.s_addr), ntohs(tcpHeader->dest));
	}

		// convert the packet's timestamp into a floating point number
		const double timestamp = (double)(pcapHeader->ts.tv_sec) + ((double)(pcapHeader->ts.tv_usec))/1000000.0;
 
  		 	// clear the output tuple 
			 	packetTuple.clear();

				// if there is an input port, copy compatible attributes from input tuple to output tuple
				// ??? packetTuple.assignFrom(inTuple, false);

			 	// assign computed values to output attributes
<% OutputAssignmentGenerator::generate("packetTuple", $model->getOutputPortAt(0)); %>

  		// send the packet tuple downstream
  		SPLLOG(L_TRACE, "submitting packetTuple=" << packetTuple, "PacketFileSource");
  		submit(packetTuple, 0);

		// count the packets and octets processed
		packetCounter++;
		octetCounter += pcapHeader->len;
    }
    
    // close the PCAP file before returning
    pcap_close(pcapDescriptor);
    pcapDescriptor = NULL;

    SPLLOG(L_INFO, "closing PCAP file '" << pcapFilename << "'", "PacketFileSource");
}





<% if ($pcapFilename) { %>

// When the 'pcapFilename' parameter is specified, this thread processes the PCAP file

void MY_OPERATOR::file_thread()
{
   SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> file_thread()", "PacketFileSource");

<% if ($processorAffinity) { %>
   // assign this thread to a particular processor core
   const uint32_t processorAffinity = <%=$processorAffinity%>;
   SPLLOG(L_INFO, "assigning thread " << gettid() << " to processor core " << processorAffinity, "PacketFileSource");
   cpu_set_t cpumask; // CPU affinity bit mask
   CPU_ZERO(&cpumask);
   CPU_SET(processorAffinity, &cpumask);
   const int rc = sched_setaffinity(gettid(), sizeof cpumask, &cpumask);
   if (rc<0) THROW (SPLRuntimeOperator, "could not set processor affinity to " << processorAffinity << ", " << strerror(errno));
<% } %>

<% if ($initDelay) { %>
   // wait for a while before starting
   const double initDelay = <%=$initDelay%>;
   SPLLOG(L_INFO, "waiting " << initDelay << " seconds before starting", "PacketFileSource");
   getPE().blockUntilShutdownRequest(initDelay);		
<% } %>

   // process the PCAP input file specified by the 'pcapFilename' parameter 
   const std::string pcapFilename = static_cast<const std::string>(<%=$pcapFilename%>);
   processPCAPfile(pcapFilename);
	
   SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> file_thread()", "PacketFileSource");
}

<% } %>




<% if ($model->getNumberOfOutputPorts()==2) { %>

// When a second output port is configured, this thread periodically calls into libpcap
// to get its statistcs counters, which are emitted as tuples on that output port

void MY_OPERATOR::statistics_thread()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> statistics_thread()", "PacketFileSource");

	// the previous values of libpcap's statistics in these variables
	previousPacketCounter = packetCounter;
	previousOctetCounter = octetCounter;

	// get statistics periodically and emit a tuple whenever they change
	double previousStatisticsTime = SPL::Functions::Time::getTimestampInSecs();
	while (1) {
		now = SPL::Functions::Time::getTimestampInSecs();
		const double timeToWait = previousStatisticsTime + statisticsInterval - now;
		if (timeToWait>0) {
				getPE().blockUntilShutdownRequest(timeToWait);				
	  	  if (getPE().getShutdownRequested()) break;
				now = SPL::Functions::Time::getTimestampInSecs();
		} else {
			  SPLLOG(L_INFO, "missed statistics interval by " << -timeToWait << " seconds", "PacketFileSource");
		}

		if ( packetCounter != previousPacketCounter ) {

  		 	// clear the output tuple and copy input attributes into it
			 	statisticsTuple.clear();

			 	// assign computed values to output attributes
<% OutputAssignmentGenerator::generate("statisticsTuple", $model->getOutputPortAt(1)); %>

				// send the statistics tuple downstream
				SPLLOG(L_TRACE, "submitting outTuple=" << statisticsTuple, "PacketFileSource");
  			submit(statisticsTuple, 1);

				// save the current statistics values for next time
				previousPacketCounter = packetCounter;
				previousOctetCounter = octetCounter;
				previousStatisticsTime = now;
		}	
  }	

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> statistics_thread()", "PacketFileSource");
}

<% } %>





<%SPL::CodeGen::implementationEpilogue($model);%>

