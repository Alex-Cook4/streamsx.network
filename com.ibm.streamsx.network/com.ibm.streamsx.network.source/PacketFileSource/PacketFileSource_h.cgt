<%

## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved

my $consistentRegion = $model->getContext()->getOptionalContext("ConsistentRegion");

%>

#include <iostream>
#include <iomanip>
#include <limits>
#include <locale>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include <sched.h>
#include <linux/if_ether.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ether.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>

#include <pcap.h>
#include <pcap-bpf.h>

#include <streams_boost/filesystem.hpp>

<%SPL::CodeGen::headerPrologue($model);%>

class MY_OPERATOR : public MY_BASE_OPERATOR 
<% if($consistentRegion) { %> , public StateHandler <% } %> 
{
public:

  // ----------- standard operator methods ----------

  MY_OPERATOR();
  virtual ~MY_OPERATOR(); 
  void allPortsReady(); 
  void prepareToShutdown(); 
  void process(uint32_t idx);
  void process(Tuple & tuple, uint32_t port);
  void process(Tuple const & tuple, uint32_t port);
  void process(Punctuation const & punct, uint32_t port);

<% if ($consistentRegion) { %>
	ConsistentRegionContext * const crContext;
	void checkpoint(Checkpoint &ckpt);
	void reset(Checkpoint &ckpt);
	void resetToInitialState();
<% } %>  	  
 
  // ----------- additional operator methods ----------

  void processPCAPfile(const std::string pcapFilename);
  void file_thread(); 
  void statistics_thread(); 

private:

  // ----------- operator parameters (constant after constructor executes) ----------

  std::string filterExpression;
  double initDelay;
  int32_t processorAffinity;
  double statisticsInterval;

  // ----------- operator state variables ----------

  double now;
  Tuple* inTuple;
  uint64_t packetCounter, previousPacketCounter;
  uint64_t octetCounter, previousOctetCounter;
  uint64_t startTimeInNanoseconds;
  boolean done;

  // ----------- libpcap-specific variables ----------

  struct pcap_pkthdr* pcapHeader;
  const u_char* pcapBuffer;
  
  // ----------- network header parser (function and state) ----------

  bool packetRawIP;
  char* packetBuffer;
  int bufferLength;
  int pktLength;

  struct ethhdr dummyEthernetHeader;
  struct ethhdr* etherHeader;
  struct ip* ipv4Header;
  struct udphdr* udpHeader;
  struct tcphdr* tcpHeader;

  int etherHeaderLength;
  int ipv4HeaderLength;
  int udpHeaderLength;
  int tcpHeaderLength;
  
  void parseNetworkHeaders(char* packet, int captureLength, int fullLength, bool isRawIP) {

	// save address and length of packet for the output attribute assignment functions 
	packetRawIP = isRawIP;
	packetBuffer = packet;
	bufferLength = captureLength;
	pktLength = fullLength;	

	// clear network header pointers
	etherHeader = NULL;
	ipv4Header = NULL;
	udpHeader = NULL;
	tcpHeader = NULL;
	etherHeaderLength = ipv4HeaderLength = udpHeaderLength = tcpHeaderLength = 0;
	
	/********* note: the following code does not handle variable-length headers yet *********/

	// if there is an ethernet header, overlay an ethernet header structure on it
	if (!isRawIP && captureLength>sizeof(struct ethhdr)) etherHeader = (struct ethhdr*)packet;
		
	// if this is an IP packet, and it actually has an IPv4 header, overlay an IPv4 header structure on it
	if ( etherHeader && ntohs(etherHeader->h_proto)==ETH_P_IP && captureLength>=sizeof(struct ethhdr)+sizeof(struct ip) ) {
	  ipv4Header = (struct ip*)(packet + sizeof(struct ethhdr)); }
	else if ( isRawIP && captureLength>=sizeof(struct ip) ) {
	  ipv4Header = (struct ip*)packet; }
	
	// if this is a UDP packet, and it actually has a UDP header, overlay a UDP header structure on it
	if ( (ipv4Header && ipv4Header->ip_p==IPPROTO_UDP && captureLength>=sizeof(struct ethhdr)+sizeof(struct ip)+sizeof(struct udphdr)) ) {
	  udpHeader = (struct udphdr*)((char*)ipv4Header + ipv4Header->ip_hl*4); }
	
	// if this is a TCP packet, and it actually has a TCP header, overlay a TCP header structure on it
	if ( (ipv4Header && ipv4Header->ip_p==IPPROTO_TCP && captureLength>=sizeof(struct ethhdr)+sizeof(struct ip)+sizeof(struct tcphdr)) ) {
	  tcpHeader = (struct tcphdr*)((char*)ipv4Header + ipv4Header->ip_hl*4); }	
  }

  // ----------- output attribute assignment functions for packet stream (port 0) ----------

  double captureTime() { 
    return (double)(pcapHeader->ts.tv_sec) + ((double)(pcapHeader->ts.tv_usec))/1000000.0; }

  uint32_t sessionKey() { 
    uint32_t key = 0;
    if (ipv4Header) key += ntohl(ipv4Header->ip_src.s_addr) + ntohl(ipv4Header->ip_dst.s_addr);
    if (udpHeader) key += ntohs(udpHeader->source) + ntohs(udpHeader->dest);
    if (tcpHeader) key += ntohs(tcpHeader->source) + ntohs(tcpHeader->dest);				
    return key; }

  uint64_t packetNumber() { 
    return packetCounter; }  

  uint32_t packetLength() { 
    return pktLength + (packetRawIP ? sizeof(struct ethhdr) : 0); } 

  SPL::blob packetData() { 
    if (!packetRawIP) return SPL::blob((const unsigned char*)packetBuffer, bufferLength); 
    dummyEthernetHeader.h_proto = htons((ipv4Header->ip_v)==6 ? ETH_P_IPV6 : ETH_P_IP);
    SPL::blob dummyPacket( (const unsigned char *)(&dummyEthernetHeader), sizeof(dummyEthernetHeader) );
    dummyPacket.append((const unsigned char *)packetBuffer, bufferLength); 
    return dummyPacket; }  

  // ---------- output attribute assignment functions for statistics stream (port 1) ----------

  double statisticsTime() { 
    return now; }

  uint64_t packetsProduced() { 
    return packetCounter - previousPacketCounter; }  

  uint64_t octetsProduced() { 
    return octetCounter - previousOctetCounter; }  

  // ------------------------------------------------------------------------------------------

}; 



<%SPL::CodeGen::headerEpilogue($model);%>

