<%

## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved

my $consistentRegion = $model->getContext()->getOptionalContext("ConsistentRegion");

%>

#include <iostream>
#include <iomanip>
#include <limits>
#include <locale>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include <sched.h>
#include <pcap.h>
#include <pcap-bpf.h>

#include <streams_boost/filesystem.hpp>

#include "parse/NetworkHeaderLocator.h"


<%SPL::CodeGen::headerPrologue($model);%>

class MY_OPERATOR : public MY_BASE_OPERATOR 
<% if($consistentRegion) { %> , public StateHandler <% } %> 
{
public:

  // ----------- standard operator methods ----------

  MY_OPERATOR();
  virtual ~MY_OPERATOR(); 
  void allPortsReady(); 
  void prepareToShutdown(); 
  void process(uint32_t idx);
  void process(Tuple & tuple, uint32_t port);
  void process(Tuple const & tuple, uint32_t port);
  void process(Punctuation const & punct, uint32_t port);

  <% if ($consistentRegion) { %>
	ConsistentRegionContext * const crContext;
	void checkpoint(Checkpoint &ckpt);
	void reset(Checkpoint &ckpt);
	void resetToInitialState();
	<% } %> ; 	  
 
  // ----------- additional operator methods ----------

  void processPCAPfile(const std::string pcapFilename);
  void file_thread(); 
  void statistics_thread(); 

 private:

  // ----------- operator parameters (constant after constructor executes) ----------

  std::string pcapFilename;
  std::string filterExpression;
  double initDelay;
  int32_t processorAffinity;
  double statisticsInterval;

  // ----------- operator state variables ----------

  double now;
  Tuple* inTuple;
  uint64_t packetCounter, previousPacketCounter;
  uint64_t octetCounter, previousOctetCounter;
  uint64_t startTimeInNanoseconds;
  boolean done;

  // ----------- libpcap-specific variables ----------

  struct pcap_pkthdr* pcapHeader;
  const u_char* pcapBuffer;
  
  // ----------- network header locator ----------

  NetworkHeaderLocator headers;

  // ----------- output attribute assignment functions for packet stream (port 0) ----------

  double captureTime() { return (double)(pcapHeader->ts.tv_sec) + ((double)(pcapHeader->ts.tv_usec))/1000000.0; }

  uint64_t packetNumber() { return packetCounter; }  

  uint32_t packetLength() { return headers.packetFullLength; } 

  SPL::blob packetData() { return SPL::blob((const unsigned char*)headers.packetBuffer, headers.packetCapturedLength); }

  uint32_t sessionKey() { // this output assignment function will probably be removed ?????????????????
    uint32_t key = 0;
    if (headers.ipv4Header) key += ntohl(headers.ipv4Header->ip_src.s_addr) + ntohl(headers.ipv4Header->ip_dst.s_addr);
    if (headers.udpHeader) key += ntohs(headers.udpHeader->source) + ntohs(headers.udpHeader->dest);
    if (headers.tcpHeader) key += ntohs(headers.tcpHeader->source) + ntohs(headers.tcpHeader->dest);				
    return key; }

  // ---------- output attribute assignment functions for statistics stream (port 1) ----------

  double statisticsTime() { return now; }

  uint64_t packetsProduced() { return packetCounter - previousPacketCounter; }  

  uint64_t octetsProduced() { return octetCounter - previousOctetCounter; }  

  // ------------------------------------------------------------------------------------------

}; 



<%SPL::CodeGen::headerEpilogue($model);%>

