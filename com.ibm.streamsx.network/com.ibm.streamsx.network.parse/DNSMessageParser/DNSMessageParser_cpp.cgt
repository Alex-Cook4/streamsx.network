<%

## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved

unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/../impl/bin";
require OutputAssignmentGenerator;

# These fragments of Perl code get strings from the operator's declaration
# in the SPL source code for use in generating C/C++ code for the operator's
# implementation below

# get the name of this operator's template
my $myOperatorKind = $model->getContext()->getKind();

# get Perl objects for input and output ports
my $inputPort = $model->getInputPortAt(0);
my $outputPort = $model->getOutputPortAt(0);

# get C++ expressions for getting the values of this operator's parameter
my $payloadAttribute = $model->getParameterByName("payloadAttribute")->getValueAt(0)->getCppExpression();

%>


<%SPL::CodeGen::implementationPrologue($model);%>

// calls to output assignment functions within expressions are generated with
// an explicit namespace matching the operator tempate name, so it must be
// equated to the operator's namespace

#define DNSMessageParser MY_OPERATOR


// Constructor
MY_OPERATOR::MY_OPERATOR()
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> constructor ...", "DNSMessageParser");

  tupleCounter = 0;

  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> constructor ...", "DNSMessageParser");
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> destructor ...", "DNSMessageParser");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> destructor ...", "DNSMessageParser");
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> allPortsReady() ...", "DNSMessageParser");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> allPortsReady() ...", "DNSMessageParser");
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> prepareToShutdown() ...", "DNSMessageParser");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> prepareToShutdown() ...", "DNSMessageParser");
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> prepareToShutdown() ...", "DNSMessageParser");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> prepareToShutdown() ...", "DNSMessageParser");
}

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process() ...", "DNSMessageParser");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "DNSMessageParser");
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process() ...", "DNSMessageParser");

  tupleCounter++;

  // point at the input tuple
  const IPort0Type& iport$0 = tuple;

  // get address and length of DNS message from input tuple
  char* buffer = (char*)<%=$payloadAttribute%>.getData();
  int bufferLength = <%=$payloadAttribute%>.getSize();

  // locate DNS fields within the DNS message
  fields.locateDNSFields(buffer, bufferLength);
  if ( ! fields.dnsHeader ) { SPLLOG(L_INFO, "ignoring tuple, no DNS header found", "DNSMessageParser");  return; }

  // submit output tuples to output ports, as selected by output filters, if specified
  outTuple.clear();
  outTuple.assignFrom(iport$0, false);
  <% OutputAssignmentGenerator::generate("outTuple", $outputPort); %> ;
  SPLLOG(L_TRACE, "submitting outTuple=" << outTuple, "DNSMessageParser");
  submit(outTuple, 0);
  
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "DNSMessageParser");
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
  SPLLOG(L_TRACE, "entering <%=$myOperatorKind%> process() ...", "DNSMessageParser");
  SPLLOG(L_TRACE, "leaving <%=$myOperatorKind%> process() ...", "DNSMessageParser");
}












<%SPL::CodeGen::implementationEpilogue($model);%>

