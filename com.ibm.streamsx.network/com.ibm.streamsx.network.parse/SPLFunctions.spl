/*
** Copyright (C) 2011, 2015  International Business Machines Corporation
** All Rights Reserved
*/

namespace com.ibm.streamsx.network.parse;


// These functions format the integer and fractional parts of a uint32, float64,
// or timestamp value representing 'Unix epoch' time (that is, seconds since
// January 1st, 1970 at midnight in Greenwich, England) as strings, according to
// a format pattern or decimal precision, respectively. They are used in the
// formatEpochDateTime() and formatEpochTime() functions below, but could be
// used directly with other patterns and precisions.

public rstring formatEpoch(uint32 seconds, rstring format) {
  timestamp ts = createTimestamp((int64)seconds, 0u);
  mutable Sys.tm tm = {};
  time(ts, tm);
  return strftime(tm, format); }

public rstring formatSubseconds(float64 seconds, uint32 precision) {
  return precision>0u ? substring(formatNumber(fmod(seconds, 1.0), 0u, precision, false), 1, (int32)precision+1) : ""; }

public rstring formatSubseconds(timestamp seconds, uint32 precision) {
  return precision>0u ? substring(formatNumber((float64)getNanoseconds(seconds)/1000000000.0, 0u, precision, false), 1, (int32)precision+1) : ""; }


// These functions format a uint32, float64, or timestamp value representing
// 'Unix epoch' time (that is, seconds since January 1st, 1970 at midnight in
// Greenwich, England) as a string in the form "YYYY-MM-DD HH:MM:SS.UUUUUU" or
// "HH:MM:SS.UUUUUU" in the local time zone. The precision for float64 and
// timestamp values defaults to microseconds if not specified.

public rstring formatEpochDateTime(uint32 seconds) { return formatEpoch(seconds, "%Y-%m-%d %H:%M:%S"); }
public rstring formatEpochTime(uint32 seconds) { return formatEpoch(seconds, "%H:%M:%S"); }

public rstring formatEpochDateTime(float64 seconds, uint32 precision) { return formatEpochDateTime((uint32)seconds) + formatSubseconds(seconds, precision); }
public rstring formatEpochTime(float64 seconds, uint32 precision) { return formatEpochTime((uint32)seconds) + formatSubseconds(seconds, precision); }

public rstring formatEpochDateTime(float64 seconds) { return formatEpochDateTime((uint32)seconds) + formatSubseconds(seconds, 6u); }
public rstring formatEpochTime(float64 seconds) { return formatEpochTime((uint32)seconds) + formatSubseconds(seconds, 6u); }

public rstring formatEpochDateTime(timestamp seconds, uint32 precision) { return formatEpochDateTime((uint32)getSeconds(seconds)) + formatSubseconds(seconds, precision); }
public rstring formatEpochTime(timestamp seconds, uint32 precision) { return formatEpochTime((uint32)getSeconds(seconds)) + formatSubseconds(seconds, precision); }

public rstring formatEpochDateTime(timestamp seconds) { return formatEpochDateTime((uint32)getSeconds(seconds)) + formatSubseconds(seconds, 6u); }
public rstring formatEpochTime(timestamp seconds) { return formatEpochTime((uint32)getSeconds(seconds)) + formatSubseconds(seconds, 6u); }


// These functions format a uint32 or float64 value representing elapsed time,
// in seconds, as a string representation of that tim in the form "DDDDd HHh MMm
// SSs" or "DDDDd HHh MMm SS.UUUUUUs", respectively, with leading zeros
// omitted. The precision for float64 values defaults to microseconds if not
// specified.

public rstring formatElapsedTime(uint32 seconds) {
  uint32 days = seconds / (24u*60u*60u);
  uint32 hours = ( seconds % (24u*60u*60u) ) / (60u*60u);
  uint32 minutes = ( seconds % (60u*60u) ) / (60u);
  uint32 sseconds = seconds % 60u;
  return ( ( days>0u ) ? (rstring)days+"d " : "" ) +
         ( ( days>0u || hours>0u ) ? (rstring)hours+"h " : "" ) +
         ( ( days>0u || hours>0u || minutes>0u ) ? (rstring)minutes+"m " : "" ) +
         (rstring)sseconds+"s"; }

public rstring formatElapsedTime(float64 seconds, uint32 precision) {
  rstring dhms = formatElapsedTime((uint32)seconds);
  if (precision==0u) return dhms;
  return substring(dhms,0,length(dhms)-1) + substring(formatNumber(fmod(seconds, 1.0), 0u, precision, false), 1, (int32)precision+1) + "s"; }

public rstring formatElapsedTime(float64 seconds) { return formatElapsedTime(seconds, 6u); }


//???rstring substr(rstring s, int32 i) { return substring(s, i, length(s)-i); }
//???rstring substr(rstring s, int32 i, int32 l) { return substring(s, i, min(l, length(s)-i)); }
