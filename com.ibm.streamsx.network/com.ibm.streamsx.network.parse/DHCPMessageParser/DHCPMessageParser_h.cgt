<%

## Copyright (C) 2011, 2015  International Business Machines Corporation
## All Rights Reserved

%>

#include "parse/DHCPMessageParser.h"

<%SPL::CodeGen::headerPrologue($model);%>

class MY_OPERATOR : public MY_BASE_OPERATOR 
{
public:

  // ----------- standard operator methods ----------

  MY_OPERATOR();
  virtual ~MY_OPERATOR(); 
  void allPortsReady(); 
  void prepareToShutdown(); 
  void process(uint32_t idx);
  void process(Tuple & tuple, uint32_t port);
  void process(Tuple const & tuple, uint32_t port);
  void process(Punctuation const & punct, uint32_t port);

private:

  // ----------- output tuples ----------

  <% for (my $i=0; $i<$model->getNumberOfOutputPorts(); $i++) { print "OPort$i\Type outTuple$i;"; } %> ;

  // ----------- operator state variables ----------

  uint64_t tupleCounter;
  
  // ----------- DHCP message parser ----------

  DHCPMessageParser parser;

  // ----------- assignment functions for output attributes ----------

  SPL::boolean parseError() { return parser.error ? true : false; }

  SPL::rstring parseErrorDescription() { return parser.error ? parser.error : ""; }

  SPL::uint32 parseErrorOffset() { return parser.error ? ( parser.dhcpEnd - parser.dhcpStart ) : 0; }

  SPL::uint64 messagesProcessed() { return tupleCounter; }

  SPL::uint8 OPCODE() { return parser.dhcpHeader ? parser.dhcpHeader->op : 0; } 

  SPL::uint8 CLIENT_HARDWARE_TYPE() { return parser.dhcpHeader ? parser.dhcpHeader->htype : 0; }

  SPL::list<SPL::uint8> CLIENT_HARDWARE_ADDRESS() { return ( parser.dhcpHeader && parser.dhcpHeader->hlen <= sizeof(parser.dhcpHeader->chaddr) ? SPL::list<SPL::uint8>(parser.dhcpHeader->chaddr, parser.dhcpHeader->chaddr + parser.dhcpHeader->hlen) : SPL::list<SPL::uint8>() ); }

  SPL::uint8 HOP_COUNT() { return parser.dhcpHeader ? parser.dhcpHeader->hops : 0; }

  SPL::uint32 TRANSACTION_IDENTIFIER() { return parser.dhcpHeader ? ntohl(parser.dhcpHeader->xid) : 0; }

  SPL::uint16 SECONDS() { return parser.dhcpHeader ? ntohs(parser.dhcpHeader->secs) : 0; }

  SPL::uint16 FLAGS() { return parser.dhcpHeader ? ntohs(parser.dhcpHeader->flags) : 0; }

  SPL::uint32 CLIENT_ADDRESS() { return parser.dhcpHeader ? ntohl(parser.dhcpHeader->ciaddr) : 0; }

  SPL::uint32 YOUR_ADDRESS() { return parser.dhcpHeader ? ntohl(parser.dhcpHeader->yiaddr) : 0; }

  SPL::uint32 DHCP_SERVER() { return parser.dhcpHeader ? ntohl(parser.dhcpHeader->siaddr) : 0; }

  SPL::uint32 RELAY_AGENT() { return parser.dhcpHeader ? ntohl(parser.dhcpHeader->giaddr) : 0; }

  SPL::rstring SERVER_HOSTNAME() { return SPL::rstring(parser.serverName); }

  SPL::rstring BOOTFILE_NAME() { return SPL::rstring(parser.bootfileName); }

  SPL::uint32 SUBNET_MASK() { return parser.dhcpOptionAsUint32(1); }

  SPL::int32 TIME_OFFSET() { return parser.dhcpOptionAsInt32(2); }

  SPL::list<SPL::uint32> ROUTERS() { return parser.dhcpOptionAsListUint32(3); }

  SPL::list<SPL::uint32> TIME_SERVERS() { return parser.dhcpOptionAsListUint32(4); }

  SPL::list<SPL::uint32> NAME_SERVERS() { return parser.dhcpOptionAsListUint32(5); }

  SPL::list<SPL::uint32> DNS_SERVERS() { return parser.dhcpOptionAsListUint32(6); }

  SPL::list<SPL::uint32> LOG_SERVERS() { return parser.dhcpOptionAsListUint32(7); }

  SPL::list<SPL::uint32> COOKIE_SERVERS() { return parser.dhcpOptionAsListUint32(8); }

  SPL::list<SPL::uint32> LPR_SERVERS() { return parser.dhcpOptionAsListUint32(9); }

  SPL::list<SPL::uint32> IMPRESS_SERVERS() { return parser.dhcpOptionAsListUint32(10); }

  SPL::list<SPL::uint32> RESOURCE_SERVERS() { return parser.dhcpOptionAsListUint32(11); }

  SPL::rstring HOST_NAME() { return parser.dhcpOptionAsString(12); }

  SPL::uint16 BOOT_FILE_SIZE() { return parser.dhcpOptionAsUint16(13); }

  SPL::rstring MERIT_DUMP_FILE() { return parser.dhcpOptionAsString(14); }

  SPL::rstring DOMAIN_NAME() { return parser.dhcpOptionAsString(15); }

  SPL::uint32 SWAP_SERVER() { return parser.dhcpOptionAsUint32(16); }

  SPL::rstring ROOT_PATH() { return parser.dhcpOptionAsString(17); }

  SPL::rstring EXTENSIONS_PATH() { return parser.dhcpOptionAsString(18); }

  SPL::boolean IP_FORWARDING() { return parser.dhcpOptionAsBoolean(19); }

  SPL::boolean NONLOCAL_SOURCE_ROUTING() { return parser.dhcpOptionAsBoolean(20); }

  SPL::list<SPL::uint32> NONLOCAL_SOURCE_FILTERS() { return parser.dhcpOptionAsListUint32(21); }

  SPL::uint16 MAXIMUM_REASSEMBLY_SIZE() { return parser.dhcpOptionAsUint16(22); }

  SPL::uint8 IP_DEFAULT_TTL() { return parser.dhcpOptionAsUint8(23); }

  SPL::uint32 MTU_AGING_TIMEOUT() { return parser.dhcpOptionAsUint32(24); }

  SPL::list<SPL::uint16> MTU_PLATEAU_TABLE() { return parser.dhcpOptionAsListUint16(25); }

  SPL::uint16 INTERFACE_MTU() { return parser.dhcpOptionAsUint16(26); }

  SPL::boolean ALL_SUBNETS_LOCAL() { return parser.dhcpOptionAsBoolean(27); }

  SPL::uint32 BROADCAST_ADDRESS() { return parser.dhcpOptionAsUint32(28); }

  SPL::boolean PERFORM_MASK_DISCOVERY() { return parser.dhcpOptionAsBoolean(29); }

  SPL::boolean MASK_SUPPLIER() { return parser.dhcpOptionAsBoolean(30); }

  SPL::boolean PERFORM_ROUTER_DISCOVERY() { return parser.dhcpOptionAsBoolean(31); }

  SPL::uint32 ROUTER_SOLICITATION_ADDRESS() { return parser.dhcpOptionAsUint32(32); }

  SPL::list<SPL::uint32> STATIC_ROUTES() { return parser.dhcpOptionAsListUint32(33); }

  SPL::boolean TRAILER_ENCAPSULATION() { return parser.dhcpOptionAsBoolean(34); }

  SPL::uint32 ARP_CACHE_TIMEOUT() { return parser.dhcpOptionAsUint32(35); }

  SPL::boolean ETHERNET_ENCAPSULATION() { return parser.dhcpOptionAsBoolean(36); }

  SPL::uint8 TCP_DEFUALT_TTL() { return parser.dhcpOptionAsUint8(37); }

  SPL::uint32 TCP_KEEPALIVE_INTERVAL() { return parser.dhcpOptionAsUint32(38); }

  SPL::boolean TCP_KEEPALIVE_GARBAGE() { return parser.dhcpOptionAsBoolean(39); }

  SPL::rstring NIS_DOMAIN() { return parser.dhcpOptionAsString(40); }

  SPL::list<SPL::uint32> NIS_SERVERS() { return parser.dhcpOptionAsListUint32(41); }

  SPL::list<SPL::uint32> NTP_SERVERS() { return parser.dhcpOptionAsListUint32(42); }

  SPL::list<SPL::uint8> VENDOR_INFORMATION() { return parser.dhcpOptionAsListUint8(43); }

  SPL::list<SPL::uint32> NETBIOS_NAME_SERVERS() { return parser.dhcpOptionAsListUint32(44); }

  SPL::list<SPL::uint32> NETBIOS_NBDD_SERVERS() { return parser.dhcpOptionAsListUint32(45); }

  SPL::uint8 NETBIOS_NODE_TYPE() { return parser.dhcpOptionAsUint8(46); }

  SPL::rstring NETBIOS_SCOPE() { return parser.dhcpOptionAsString(47); }

  SPL::list<SPL::uint32> XWINDOW_FONT_SERVERS() { return parser.dhcpOptionAsListUint32(48); }

  SPL::list<SPL::uint32> XWINDOW_DISPLAY_MANAGERS() { return parser.dhcpOptionAsListUint32(49); }

  SPL::uint32 REQUESTED_ADDRESS() { return parser.dhcpOptionAsUint32(50); }

  SPL::uint32 ADDRESS_LEASE_TIME() { return parser.dhcpOptionAsUint32(51); }

  SPL::uint8 OPTION_OVERLOAD_FLAGS() { return parser.dhcpOptionAsUint8(52); }

  SPL::uint8 DHCP_MESSAGE_TYPE() { return parser.dhcpOptionAsUint8(53); }

  SPL::uint32 SERVER_ADDRESS() { return parser.dhcpOptionAsUint32(54); }

  SPL::list<SPL::uint8> PARAMETER_REQUESTS() { return parser.dhcpOptionAsListUint8(55); }

  SPL::rstring ERROR_MESSAGE() { return parser.dhcpOptionAsString(56); }

  SPL::uint16 MAXIMUM_DHCP_MESSAGE_SIZE() { return parser.dhcpOptionAsUint16(57); }

  SPL::uint32 RENEWAL_TIME() { return parser.dhcpOptionAsUint32(58); }

  SPL::uint32 REBINDING_TIME() { return parser.dhcpOptionAsUint32(59); }

  SPL::list<SPL::uint8> VENDOR_IDENTIFIER() { return parser.dhcpOptionAsListUint8(60); }

  SPL::list<SPL::uint8> CLIENT_IDENTIFIER() { return parser.dhcpOptionAsListUint8(61); }

  SPL::rstring NISPLUS_DOMAIN() { return parser.dhcpOptionAsString(64); }

  SPL::list<SPL::uint32> NISPLUS_SERVERS() { return parser.dhcpOptionAsListUint32(65); }

  SPL::list<SPL::uint32> MOBILE_IP_HOME_AGENTS() { return parser.dhcpOptionAsListUint32(68); }

  SPL::list<SPL::uint32> SMTP_SERVERS() { return parser.dhcpOptionAsListUint32(69); }

  SPL::list<SPL::uint32> POP3_SERVERS() { return parser.dhcpOptionAsListUint32(70); }

  SPL::list<SPL::uint32> NNTP_SERVERS() { return parser.dhcpOptionAsListUint32(71); }

  SPL::list<SPL::uint32> WWW_SERVERS() { return parser.dhcpOptionAsListUint32(72); }

  SPL::list<SPL::uint32> FINGER_SERVERS() { return parser.dhcpOptionAsListUint32(73); }

  SPL::list<SPL::uint32> IRC_SERVERS() { return parser.dhcpOptionAsListUint32(74); }

  SPL::list<SPL::uint32> STREETTALK_SERVERS() { return parser.dhcpOptionAsListUint32(75); }

  SPL::list<SPL::uint32> STDA_SERVERS() { return parser.dhcpOptionAsListUint32(76); }

}; 

<%SPL::CodeGen::headerEpilogue($model);%>

