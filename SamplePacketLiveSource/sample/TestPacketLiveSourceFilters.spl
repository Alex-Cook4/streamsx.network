/*
** Copyright (C) 2011, 2015  International Business Machines Corporation
** All Rights Reserved
*/

namespace sample;

use com.ibm.streamsx.network.mac::*;
use com.ibm.streamsx.network.ipv4::*;
use com.ibm.streamsx.network.source::*;

composite TestPacketLiveSourceFilters {

	param		
	expression<rstring> $networkInterface: getSubmissionTimeValue("networkInterface", "eth0");
    expression<float64> $timeoutInterval: (float64)getSubmissionTimeValue("timeoutInterval", "10.0" );
	
	type 
	
	DHCPPacketType =
	  float64 captureTime,				// time that packet was captured, in seconds since Unix epoch 
	  uint64 packetNumber,				// sequence number of packet, as emitted by operator
	  rstring etherSourceAddress,		// ethernet source address, or empty list if 'raw IP' PCAP recording
	  rstring etherDestinationAddress,	// ethernet destination address, or empty list if 'raw IP' PCAP recording
	  rstring ipSourceAddress,			// IP source address
	  rstring ipDestinationAddress,		// IP destination address
	  uint32 dhcpLength,				// length of DHCP message in packet (possibly truncated))
	  blob dhcpMessage;					// DHCP message, excluding network headers (possibly truncated)

	DNSPacketType =
	  float64 captureTime,				// time that packet was captured, in seconds since Unix epoch 
	  uint64 packetNumber,				// sequence number of packet, as emitted by operator
	  rstring ipSourceAddress,			// IP source address
	  rstring ipDestinationAddress,		// IP destination address
	  uint32 dnsLength,					// length of DNS message in packet (possibly truncated))
	  blob dnsMessage;					// DNS message, excluding network headers (possibly truncated)

	HTTPPacketType =
	  float64 captureTime,				// time that packet was captured, in seconds since Unix epoch 
	  uint64 packetNumber,				// sequence number of packet, as emitted by operator
	  rstring ipSourceAddress,			// IP source address and port
	  rstring ipDestinationAddress,		// IP destination address and port
	  uint32 httpLength,				// length of HTTP data in packet (possibly truncated))
	  blob httpData;					// HTTP data, excluding network headers (possibly truncated)

	PingPacketType =
	  float64 captureTime,				// time that packet was captured, in seconds since Unix epoch 
	  uint64 packetNumber,				// sequence number of packet, as emitted by operator
	  rstring ipSourceAddress,			// IP source address 
	  rstring ipDestinationAddress,		// IP destination address 
	  uint32 pingLength,				// length of Ping message in packet (possibly truncated))
	  blob pingMessage;					// Ping message, excluding network headers (possibly truncated)

	AllPacketType =
		float64 captureTime,			// time that packet was captured, in seconds since Unix epoch 
		uint64 packetNumber,			// sequence number of packet, as emitted by operator
	    uint8 ipVersion,				// IP version: 4 for IPv4, 6 for IPv6
	    rstring ipProtocol,				// IP protocol: 0x01==1 for ICMP, 0x6==6 for TCP, 0x11==17 for UDP
	    rstring ipSourceAddress,		// IP source address, or empty if not IP packet
	    uint16 ipSourcePort,			// IP source port, or zero if not UDP or TCP packet
	    rstring ipDestinationAddress,	// IP destination address, or empty if not IP packet
	    uint16 ipDestinationPort,		// IP destination port, or zero if not UDP or TCP packet
		uint32 payloadLength,			// length of packet payload, following all network headers
		uint32 packetLength,			// original length of packet (not necessarily all captured)
		blob packetData;				// contents of packet captured, including network headers (possibly truncated)

	graph

	( stream<DHCPPacketType> DHCPPacketStream as DHCPOut ; 
	  stream<DNSPacketType> DNSPacketStream as DNSOut ;
	  stream<HTTPPacketType> HTTPPacketStream as HTTPOut ;
	  stream<PingPacketType> PingPacketStream as PingOut ;
	  stream<AllPacketType> AllPacketStream as AllOut ) = PacketLiveSource() {
	    logic state: { map<uint8,rstring> ipProtocols = { 1: "icmp", 6: "tcp", 17: "udp" }; } 
		param
			networkInterface: $networkInterface;
		    inputFilter:   "udp or icmp or tcp";            // process only UDP and ICMP payloads
		    outputFilters: "udp port 67 or udp port 68",    // output port 0 emits only DHCP payloads
                           "udp port 53",                   // output port 1 emits only DNS payloads
                           "tcp port 80",                   // output port 2 emits only HTTP payloads
                           "icmp[icmptype] = icmp-echo or icmp[icmptype] = icmp-echoreply", // output port 3 emits only Ping payloads
                           "";                              // output port 4 emits all packets processed
		output 
		DHCPOut:
			captureTime = captureTime(),
			packetNumber = packetsProcessed() - 1ul,
			etherSourceAddress = convertMACAddressNumericToString(ETHER_SRC_ADDRESS()),
			etherDestinationAddress = convertMACAddressNumericToString(ETHER_DST_ADDRESS()),
			ipSourceAddress = convertIPV4AddressNumericToString(IPV4_SRC_ADDRESS()),
			ipDestinationAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()),
			dhcpLength = payloadLength(),
			dhcpMessage = payloadData(); 
		DNSOut:
			captureTime = captureTime(),
			packetNumber = packetsProcessed() - 1ul,
			ipSourceAddress = convertIPV4AddressNumericToString(IPV4_SRC_ADDRESS()),
			ipDestinationAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()),
			dnsLength = payloadLength(),
			dnsMessage = payloadData(); 
		HTTPOut:
			captureTime = captureTime(),
			packetNumber = packetsProcessed() - 1ul,
			ipSourceAddress = convertIPV4AddressNumericToString(IPV4_SRC_ADDRESS()) + ":" + (rstring)TCP_SRC_PORT(),
			ipDestinationAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()) + ":" + (rstring)TCP_DST_PORT(),
			httpLength = payloadLength(),
			httpData = payloadData(); 
		PingOut:
			captureTime = captureTime(),
			packetNumber = packetsProcessed() - 1ul,
			ipSourceAddress = convertIPV4AddressNumericToString(IPV4_SRC_ADDRESS()),
			ipDestinationAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()),
			pingLength = payloadLength(),
			pingMessage = payloadData(); 
		AllOut:
			captureTime = captureTime(),
			packetNumber = packetsProcessed() - 1ul,
			ipVersion = IP_VERSION(),
			ipProtocol = IP_PROTOCOL() in ipProtocols ? ipProtocols[IP_PROTOCOL()] : (rstring)IP_PROTOCOL(),
			ipSourceAddress = convertIPV4AddressNumericToString(IPV4_SRC_ADDRESS()),
			ipDestinationAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()),
			ipSourcePort = IP_SRC_PORT(),
			ipDestinationPort = IP_DST_PORT(),
			payloadLength = payloadLength(),
		    packetLength = packetLength(),
			packetData = packetData();
	}
	() as DHCPPacketSink = FileSink(DHCPPacketStream) { param file: "debug.TestPacketFileSourceFilters.DHCPPacketStream.out"; format: txt; hasDelayField: true; flush: 1u; }	
	() as DNSPacketSink = FileSink(DNSPacketStream) { param file: "debug.TestPacketFileSourceFilters.DNSPacketStream.out"; format: txt; hasDelayField: true; flush: 1u; }	
	() as HTTPPacketSink = FileSink(HTTPPacketStream) { param file: "debug.TestPacketFileSourceFilters.HTTPPacketStream.out"; format: txt; hasDelayField: true; flush: 1u; }	
	() as PingPacketSink = FileSink(PingPacketStream) { param file: "debug.TestPacketFileSourceFilters.PingPacketStream.out"; format: txt; hasDelayField: true; flush: 1u; }	
	() as AllPacketSink = FileSink(AllPacketStream) { param file: "debug.TestPacketFileSourceFilters.AllPacketStream.out"; format: txt; hasDelayField: true; flush: 1u; }	

	() as Timeout = Custom() { logic onProcess: { block($timeoutInterval); shutdownPE(); } }

}

