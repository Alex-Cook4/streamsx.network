/*
** Copyright (C) 2011, 2015  International Business Machines Corporation
** All Rights Reserved
*/

namespace sample;

use spl.file::*;
use com.ibm.streamsx.network.ipv4::*;
use com.ibm.streamsx.network.ipv6::*;
use com.ibm.streamsx.network.mac::*;
use com.ibm.streamsx.network.source::*;
use com.ibm.streamsx.network.content::*;
use com.ibm.streamsx.network.datetimeformat::*;

composite TestPacketContentAssemblerFlowsAndFiles {

  param
    expression<rstring> $pcapFilename: getSubmissionTimeValue("pcapFilename", "./firewallcontent_sample.pcap");

  type

  PacketType =
    float64 captureTime,    // time that packet was captured, in seconds since Unix epoch
    blob rawPacket ;        // contents of packet captured, including all headers

  FlowDataType =
    rstring flowEventTime,
    rstring ipSource,
    rstring ipDestination,
    boolean tlsEvent,
    rstring flowDirection,
    uint64 flowID,
    uint32 transactionID,
    rstring flowProtocol,
    rstring tlsRecordType,
    rstring tlsRecordDirection,
    uint32 tlsRecordLength,
    uint32 tlsRecordOffset,
    boolean tlsRecordMore,
    boolean flowDataInitial,
    rstring flowData;

  FileChunkType =
    uint64 flowID,
    uint32 transactionID,
    uint64 fileID,
    rstring fileExtension,
    boolean fileChunkInitial,
    blob fileChunk;

  graph

    stream<PacketType> PacketStream as Out = PacketFileSource() {
    param
      pcapFilename: $pcapFilename;
      inputFilter: "tcp";
      metricsInterval: 0.0;
    output Out:
      captureTime = (float64)CAPTURE_SECONDS() + (float64)CAPTURE_MICROSECONDS() / 1000000.0,
      rawPacket = PACKET_DATA(); }
    //() as PacketSink = FileSink(PacketStream) { param file: "debug.TestPacketContentAssemblerFlowsAndFiles.PacketStream.out" ; format: csv ; hasDelayField: true ; }

  ( stream<FlowDataType> FlowDataStream as Flow ;
    stream<FileChunkType> FileChunkStream as File ) = PacketContentAssembler(PacketStream) {
    param
    timestampAttribute: captureTime;
    packetAttribute: rawPacket;
    outputFilters: ( EVENT_FLOW_DATA() && FLOW_PROTOCOL()!="unknown" && FLOW_PROTOCOL()!="" ) || EVENT_FLOW_TLS(), 
                   EVENT_FILE_DATA() && mimetype2extension(FILE_CONTENT_TYPE())!="";
    pamTuning: "pam.content.consume.archives=on",
               "pam.content.gif.enabled=true",
               "pam.content.docx.decompress=false",
               "pam.content.pptx.decompress=false",
               "pam.content.xlsx.decompress=false" ;
    output
    Flow:
      flowEventTime = formatEpochDateTime(FLOW_EVENT_TIME()),
      ipSource = convertIPV4AddressNumericToString(FLOW_IPV4_SRC_ADDRESS()) + ":" + (rstring)FLOW_SRC_PORT(),
      ipDestination = convertIPV4AddressNumericToString(FLOW_IPV4_DST_ADDRESS()) + ":" + (rstring)FLOW_DST_PORT(),
      tlsEvent = EVENT_FLOW_TLS(),
      flowDirection = FLOW_DIRECTION(),
      flowID = FLOW_ID(),
      transactionID = FLOW_TRANSACTION_ID(),
      flowProtocol = EVENT_FLOW_TLS() ? "tls" : FLOW_PROTOCOL(),
      tlsRecordType = TLS_RECORD_TYPE(),
      tlsRecordDirection = TLS_RECORD_DIRECTION(),
      tlsRecordLength = TLS_RECORD_LENGTH(),
      tlsRecordOffset = TLS_RECORD_OFFSET(),
      tlsRecordMore = TLS_RECORD_MORE(),
      flowDataInitial = FLOW_DATA_COUNTER()==0ul,
      flowData = FLOW_DATA_STRING();
    File:
      flowID = FLOW_ID(),
      transactionID = FLOW_TRANSACTION_ID(),
      fileID = FILE_ID(),
      fileExtension = mimetype2extension(FILE_CONTENT_TYPE()),
      fileChunkInitial = FILE_CHUNK_INITIAL(),
      fileChunk = FILE_CHUNK_BINARY();
  }
  () as FlowDataSink = FileSink(FlowDataStream) { param file: "debug.TestPacketContentAssemblerFlowsAndFiles.FlowDataStream.out" ; suppress: flowData; format: txt ; hasDelayField: true ; }
  () as FileChunkSink = FileSink(FileChunkStream) { param file: "debug.TestPacketContentAssemblerFlowsAndFiles.FileChunkStream.out" ; suppress: fileChunk; format: txt ; hasDelayField: true ; }

  () as FlowDataStore = Custom(FlowDataStream as In) {
    logic state: {
      map<rstring,rstring> directionFlags = {
        "?"        : "????????",
        ""         : "--------",
        "SrcToDst" : ">>>>>>>>",
        "DstToSrc" : "<<<<<<<<" }; }
    onTuple In: {
      rstring filename = dataDirectory() + "/debug.TestPacketContentAssemblerFlowsAndFiles/debug.flow_" + leadingZeros(flowID,6) + "." + flowProtocol;
      rstring filemode = flowDataInitial ? "w" : "a";
      mutable int32 error = 0;
      uint64 handle = fopen(filename, filemode, error);
      assert(error==0, "Sorry, could not open output file '" + filename + "', " + strerror(error));
      if (tlsEvent) {
        fwriteString("TLS " + tlsRecordType + " " + tlsRecordDirection + " (bytes " + (rstring)tlsRecordOffset + " to " + (rstring)(tlsRecordOffset+(uint32)length(flowData)) + (tlsRecordMore ? ", more..." : "") + ")\n", handle, error);
        assert(error==0, "Sorry, could not write output file '" + filename + "', " + strerror(error));
      } else {
        fwriteString("\n" + flowEventTime + " -- " + ipSource + " " + directionFlags[flowDirection] + " " + ipDestination + " (" + (rstring)length(flowData) + " bytes of " + flowProtocol + ")\n", handle, error);
        assert(error==0, "Sorry, could not open output file '" + filename + "', " + strerror(error));
        fwriteString(trancateNonASCII(flowData) + "\n", handle, error);
        assert(error==0, "Sorry, could not write output file '" + filename + "', " + strerror(error));
      }
      fclose(handle, error);
      assert(error==0, "Sorry, could not close output file '" + filename + "', " + strerror(error)); } }

  () as FileChunkStore = Custom(FileChunkStream as In) {
    logic onTuple In: {
      rstring filename = dataDirectory() + "/debug.TestPacketContentAssemblerFlowsAndFiles/debug.flow_" + leadingZeros(flowID,6) + "_file_" + leadingZeros(fileID,6) + "." + fileExtension;
      rstring filemode = fileChunkInitial ? "w" : "a";
      mutable int32 error = 0;
      uint64 handle = fopen(filename, filemode, error);
      assert(error==0, "Sorry, could not open output file '" + filename + "', " + strerror(error));
      fwriteblob(fileChunk, handle, error);
      assert(error==0, "Sorry, could not write output file '" + filename + "', " + strerror(error));
      fclose(handle, error);
      assert(error==0, "Sorry, could not close output file '" + filename + "', " + strerror(error));
    } }

}
