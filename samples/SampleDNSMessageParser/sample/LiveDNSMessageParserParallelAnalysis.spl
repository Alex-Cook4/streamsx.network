/*
** Copyright (C) 2011, 2015  International Business Machines Corporation
** All Rights Reserved
*/

namespace sample;

use com.ibm.streamsx.network.ipv4::*;
use com.ibm.streamsx.network.source::*;
use com.ibm.streamsx.network.parse::*;

composite LiveDNSMessageParserParallelAnalysis {

    param       
	expression<rstring> $networkInterface: getSubmissionTimeValue("networkInterface", "eth0");
	expression<rstring> $inputFilter: getSubmissionTimeValue("inputFilter", "udp port 53");
    expression<float64> $metricsInterval: (float64)getSubmissionTimeValue("metricsInterval", "1.0" );
    expression<float64> $timeoutInterval: (float64)getSubmissionTimeValue("timeoutInterval", "10.0" );
    expression<int32> $parallelChannels: (int32)getSubmissionTimeValue("parallelChannels", "1" );
    
    type 
    
	// packet output from PacketLiveSource operator
    PacketType =
        timestamp captureTime,          // time that packet was captured, in seconds since Unix epoch 
        rstring dstAddress,             // string representation of IPv4 destination address
	    uint64 partitionKey,			// combination of addresses and ports, for downstream @parallel annotation
        blob dnsMessage;                // the DNS message from a packet, excluding all network headers

	// metrics output from PacketLiveSource operator
	MetricsType = 
		float64 metricsTime,			// time that metrics were produced, in seconds since Unix epoch 
	    float64 averagePacketsReceived,	// average number of packets received during last metrics interval
	    float64 averagePacketsDropped,	// average number of packets dropped during last metrics interval
	    float64 averagePacketsProcessed,// average number of packets processed during last metrics interval
	    float64 averageOctetsProcessed;	// average number of octets processed during last metrics interval

    graph

    ( stream<PacketType> PacketStream as PacketsOut ;
	  stream<MetricsType> MetricsStream as MetricsOut ) = PacketLiveSource() {
        param
			networkInterface: $networkInterface;
		    promiscuous: true;
            metricsInterval: $metricsInterval;
            inputFilter: $inputFilter;
		    outputFilters: true, metricsUpdated();
        output 
		PacketsOut:
            captureTime = createTimestamp( (int64)CAPTURE_SECONDS(), CAPTURE_MICROSECONDS() * 1000u ),
            dstAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()),
		    partitionKey = hashCode(IPV4_SRC_ADDRESS()) + 
		                   hashCode(IPV4_DST_ADDRESS()) + 
		                   hashCode(IPV6_SRC_ADDRESS()) + 
		                   hashCode(IPV6_DST_ADDRESS()) + 
		                   hashCode(IP_SRC_PORT()) + 
		                   hashCode(IP_DST_PORT()),
            dnsMessage = PAYLOAD_DATA();
		MetricsOut:
		    metricsTime = getTimestampInSecs(),
	        averagePacketsReceived = (float64)metricsIntervalPacketsReceived() / metricsIntervalElapsed(),
	        averagePacketsDropped = (float64)metricsIntervalPacketsDropped() / metricsIntervalElapsed(),
	        averagePacketsProcessed = (float64)metricsIntervalPacketsProcessed() / metricsIntervalElapsed(),
	        averageOctetsProcessed = (float64)metricsIntervalOctetsProcessed() / metricsIntervalElapsed();
    }
    () as PacketSink = FileSink(PacketStream) { param file: "debug.LiveDNSMessageParserParallelAnalysis.PacketStream.out"; format: txt; hasDelayField: true; flush: 1u; }   
    () as MetricsSink = FileSink(MetricsStream) { param file: "debug.LiveDNSMessageParserParallelAnalysis.MetricsStream.out"; format: txt; hasDelayField: true; flush: 1u; }   

	@parallel(width=$parallelChannels, partitionBy=[{port=PacketStream, attributes=[partitionKey]}])
	( stream<LiveDNSAnalytics.PBDNSAnalyticResultType> PBDNSAnalyticResultStream ;
	  stream<LiveDNSAnalytics.DPDNSAnalyticResultType> DPDNSAnalyticResultStream ;
	  stream<LiveDNSAnalytics.HPDNSAnalyticResultType> HPDNSAnalyticResultStream ) = LiveDNSAnalytics(PacketStream) {} 

	() as Timeout = Custom() { logic onProcess: { block($timeoutInterval); shutdownPE(); } }
}



composite LiveDNSAnalytics ( input PacketStream ; output PBDNSAnalyticResultStream, DPDNSAnalyticResultStream, HPDNSAnalyticResultStream ) {

  type

    // input to 'predictive blacklisting' analytic
    PBDNSResponseMessage_t = 
      timestamp captureTime,
      rstring dstAddress,
      rstring questionName,
	  uint16 questionType,
      uint8 responseCode,
	  uint16 answerCount,
      list<rstring> answerData,
      list<uint16> answerTypes,
      list<uint32> answerTTLs,
	  uint16 nameserverCount,
      list<rstring> nameserverData,
      list<uint16> nameserverTypes,
      list<uint32> nameserverTTLs,
	  uint16 additionalCount,
      list<rstring> additionalData,
      list<uint16> additionalTypes,
      list<uint32> additionalTTLs;
  
    // input to 'domain profiling' and 'host profiling' analytics
    DPHPDNSResponseMessage_t = 
	  timestamp captureTime,
	  rstring dstAddress,
	  rstring questionName,
	  uint16 questionType,
	  uint8 responseCode,
	  list<rstring> answerData,
	  list<rstring> additionalData;

    // output from 'predictive blacklisting' analytic
    static PBDNSAnalyticResultType = 
	  int32 result;

    // output from 'domain profiling' analytic
    static DPDNSAnalyticResultType = 
	  int32 result;

    // output from 'host profiling' analytic
    static HPDNSAnalyticResultType = 
	  int32 result;

  graph
	
    ( stream<PBDNSResponseMessage_t> PBDNSResponseMessageStream as OutPB ;
	  stream<DPHPDNSResponseMessage_t> DPHPDNSResponseMessageStream as OutDPHP ) = DNSMessageParser(PacketStream) {
      param
          messageAttribute: dnsMessage;
          outputFilters: DNS_RESPONSE_FLAG() && !parseError(), 
	                     DNS_RESPONSE_FLAG() && !parseError();
      output 
	  OutPB:
          questionName = DNS_QUESTION_NAME(),
	      questionType = DNS_QUESTION_TYPE(),
          responseCode = DNS_RESPONSE_CODE(),
	      answerCount = DNS_ANSWER_COUNT(),
          answerData = DNS_ANSWER_DATA(),
          answerTypes = DNS_ANSWER_TYPES(),
          answerTTLs = DNS_ANSWER_TTLS(),
	      nameserverCount = DNS_NAMESERVER_COUNT(),
          nameserverData = DNS_NAMESERVER_DATA(),
          nameserverTypes = DNS_NAMESERVER_TYPES(),
          nameserverTTLs = DNS_NAMESERVER_TTLS(),
	      additionalCount = DNS_ADDITIONAL_COUNT(),
          additionalData = DNS_ADDITIONAL_DATA(),
          additionalTypes = DNS_ADDITIONAL_TYPES(),
          additionalTTLs = DNS_ADDITIONAL_TTLS();
      OutDPHP:
          questionName = DNS_QUESTION_NAME(),
	      questionType = DNS_QUESTION_TYPE(),
          responseCode = DNS_RESPONSE_CODE(),
          answerData = DNS_ANSWER_DATA(),
          additionalData = DNS_ADDITIONAL_DATA();
    }
    () as PBDNSResponseMessageSink = FileSink(PBDNSResponseMessageStream) { param file: "debug.LiveDNSMessageParserParallelAnalysis.PBDNSResponseMessageStream" + (rstring)getChannel() + ".out"; format: txt; hasDelayField: true; flush: 1u; } 
    () as DPHPDNSResponseMessageSink = FileSink(DPHPDNSResponseMessageStream) { param file: "debug.LiveDNSMessageParserParallelAnalysis.DPHPDNSResponseMessageStream" + (rstring)getChannel() + ".out"; format: txt; hasDelayField: true; flush: 1u; } 

	// placeholder for 'predictive blacklisting' analytic
	stream<PBDNSAnalyticResultType> PBDNSAnalyticResultStream = Custom(PBDNSResponseMessageStream) {} 

	// placeholder for 'domain profiling' analytic
	stream<DPDNSAnalyticResultType> DPDNSAnalyticResultStream = Custom(DPHPDNSResponseMessageStream) {} 

	// placeholder for 'host profiling' analytic
	stream<HPDNSAnalyticResultType> HPDNSAnalyticResultStream = Custom(DPHPDNSResponseMessageStream) {} 

}



